기초 웹 스터디 8주차 - 2023년 5월 16일 화요일

이번 주 WIL인 WIL8에 담을 내용은 잘 정리되어 있는 래퍼런스 사이트에서 정해준 내용을 공부한 후 내가 새로 알게 된 내용 및 기억하고 싶은 내용을 정리한 것이다.  

## JavaScript

(1, 5, 6, 7, 8, 9, 14, 15)

1. 기본 개념과 동작 원리 이해의 중요성
   
   1> 프로그래밍이란?

   (1) 프로그래밍 : 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션

   즉, 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것

   (2) 프로그래밍은 문제 해결 능력을 요구하며 정확하게 상세하게 요구사항을 설명하는 작업이다. 

   2> 프로그래밍 언어

   (1) 프로그래밍 언어는 Syntax(구문, 문법)와 Semantics(의미)의 조합으로 표현된다.

   => 용어 정리

      1] 기계어(Machine code) : 컴퓨터가 이해할 수 있는 언어

      2] 컴파일러(compiler) 혹은 인터프리터(interpreter) : 프로그래밍 언어를 컴퓨터가 이해할 수 있는 기계어로 변환하여 주는 일종의 번역기 

      3] 언어(language) : 자신의 생각을 상대에게 전달하는 방법으로 언어 공동체 내에서 이해될 수 있는 말의 집합

      (언어에는 자연어(인간이 이해할 수 있는 언어)와 인공어로 구분할 수 있다.)

   3> Syntax & Semantics (문법 & 의미)

   (1) Syntax(문법) : 문제 해결 능력을 통해 만들어낸 해결 방안은 프로그래밍 언어의 문법을 통해 표현한다.
   (작성된 코드 : 해결 방안의 구체적 구현물)

   (2) Semantics(의미) : 프로그래밍 언어의 문법에 부합하는 것은 물론, 요구사항이 실현(문제가 해결)되어야 의미가 있다.

   4> 기본 개념과 동작 원리 이해의 중요성

   (1) 프로그래머가 해야 할 일 : 문제를 해결하기 위한 방안을 고안하고 이것을 문법에 맞게 코드로 구현하는 것
   -> 기본 개념과 동작 원리를 정확히 이해하는 것이 중요하다.

   (2) 기본 개념 
   
      1] 문맥에 맞는 정확한 용어를 사용할 수 있게 돕는다.

      2] 문맥에 맞는 정확한 용어의 사용 : 오해를 불러 일으키지 않는 명확한 의사 소통을 가능케 한다. -> 협업의 기본이며 필수 요소

   (3) 동작 원리 이해

      1] 코드의 동작을 예측할 수 있게 돕는다.

      2] 코드의 동작을 예측할 수 있는 능력 : 필수 불가결적 요소

   (4) 기본 개념과 동작 원리의 이해 : 어렵고 생소한 용어들로 이루어진 기술적 의사 소통을 가능케 하고, 자신의 머릿속에서 코드를 실행시켜 볼 수 있는 능력을 갖게 한다.

2. 자바스크립트의 기본 문법
   
   1> 변수
   
      1] 정의 : 메모리 주소(Memory address)에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자(identifier)

      2] 사용 목적 : 값(vlaue)을 저장(할당)하고 그 저장된 값을 참조하기 위해
      (변수의 이름을 통해 값의 의미를 명확히 할 수 있어 코드의 가독성이 좋아진다.)

      3] 선언 : 'var' 키워드 사용

      4] 할당 : 할당 연산자 '=' 사용

      5] 예시
      
        1} var = x; 
           x = 6;

        2} var x = 6;
      
   2> 값

      1] 정의 : 프로그램에 의해 조작될 수 있는 대상

      2] 생성 방법 : 리터럴 표기법(literal notation) 등

      3] 데이터 타입

        1} 원시 타입(primitive data type)

          1) number

          2) string

          3) boolean

          4) null

          5) undefined

          6) symbol (New in ECMAScript6)

          => 다양한 연산자의 피연산자가 되어 하나의 값으로 평가될 수 있다.
          -> 리터럴은 연산에 의해 하나의 값이 될 수 있다.

        2} 객체 타입 (Object data type)

          1) object

        3} 동적 타이핑 : 변수에 할당된 값의 타입에 의해 동적으로 변수의 타입이 결정되는 것

          => 자바스크립트가 다른 프로그래밍 언어와 구별되는 특징 중 하나이다.

        4} 용어 정리

          1) 데이터 타입(Data Type) : 프로그래밍 언어에서 사용할 수 있는 값의 종류

          2) 변수(Variable) : 값이 저장된 메모리 공간의 주소를 가리키는 식별자(identifier)

          3) 리터럴(literal) : 소스코드 안에서 직접 만들어 낸 상수 값 자체를 말하며 값을 구성하는 최소 단위

   3> 연산자(Operator)

      1] 정의 : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다.

      2] 피연산자(Operand) : 연산의 대상

      3] 자바스크립트는 암묵적 타입 강제 변환을 통해 연산을 수행한다.

   4> 키워드(keyword)

      1] 정의 : 수행할 동작을 규정한 것

      2] 예시

        1} var 키워드 : 새로운 변수를 생성할 것을 지시한다.

   5> 주석(Comment)

      1] 사용 목적 : 작성된 코드의 의미를 설명하기 위해
      (가독성이 좋아지게 하기 위해)

      2] 사용 방법

        1} 한 줄 주석 : '//' 다음에 작성한다.

        2} 여러 줄 주석 : '/*'과 '*/'의 사이에 작성한다.

      3] 주석은 해석기(parser)가 무시하며 실행되지 않는다.

      4] 주의사항 : 과도한 주석은 오히려 가독성을 해칠 수 있다.

   6> 문

      1] 프로그램(스크립트) : 컴퓨터(Client-side Javascript의 경우, 엄밀히 말하면 웹 브라우저)에 의해 단계별로 수행될 명령들의 집합

      2] 문(statement) : 각각의 명령
      -> 문이 실행되면 무슨 일인가가 일어나게 된다.

      3] 리터럴(literal), 연산자(Operator), 표현식(Expression), 키워드(Keyword) 등으로 구성되며 세미콜론(;)으로 끝나야 한다.

      4] 그룹화

        1} 문은 코드 블록(code block, {...})으로 그룹화할 수 있다.

        2} 목적 : 함께 실행되어져야 하는 문을 정의하기 위해

      5] 순서

        1} 일반적인 순서 : 위에서 아래로 순서대로 실행된다.

        2} 흐름 제어(Control Flow) : 조건문(if, switch)이나 반복문(while, for)의 사용으로 제어할 수 있다.

        3} 또는 함수 호출로 변경될 수 있다.

      6] 자바스크립트에서는 함수 단위의 유효범위(Function-level scope)만이 생성된다.

   7> 표현식

      1] 표현식(Expression)은 하나의 값으로 평가(Evaluation)된다.

      2] 표현식의 종류

         1} 값(리터럴)

         2} 변수

         3} 객체의 프로퍼티

         4} 배열의 요소

         5} 함수 호출

         6} 메소드 호출

         7} 피연산자와 연산자의 조합

      3] 표현식은 다른 표현식의 일부가 되어 조금 더 복잡한 표현식을 구성할 수도 있다. 
      -> 표현식은 결국 하나의 값이 되기 때문이다.

   8> 문과 표현식의 비교

      1] 문(Statement)

        1} 정의 : 마침표로 끝나는 하나의 완전한 문장

        2} 표현식을 통해 평가한 값을 통해 실제로 컴퓨터에게 명령을 하여 무언가를 하는 것이다.

      2] 표현식 : 문을 구성하는 요소

        1} 정의 : 문을 구성하는 요소

        2} 평가되어 값을 만들지만 그 이상의 행위를 할 수 없다.

        3} 표현식은 그 자체로 하나의 문이 될 수도 있다.

   9> 함수

      1] 정의 : 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록

      2] 호출

        1} 함수는 이름과 매개변수를 갖고 필요할 때에 호출한다.

        2} 함수는 호출에 의해 실행된다.

        3} 한 번만 호출할 수 있는 것이 아니라 여러 번 호출할 수 있다.

      3] 코드의 재사용 : 동일한 작업을 반복적으로 수행해야 한다면 미리 정의된 함술르 재사용하는 것이 효율적이다.

   10> 객체

      1] 자바스크립트 : 객체(object) 기반의 스크립트 언어

      2] 객체

        1} 정의 : 데이터를 의미하는 프로퍼티(property)의 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합

        2] 구조화 : 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다.
        -> 객체는 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문이다.

        2} 자바스크립트를 이루고 있는 거의 모든 것
        => 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)

      3] 자바스크립트 객체

        1} 정의 : 키(이름)와 값으로 구성된 프로퍼티(property)의 집합

        2} 프로퍼티의 값 : 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다.

        3} 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다.

        4} 객체지향의 상속을 구현하기 위해 "프로토타입"이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다.

   11> 배열(array)

      1] 사용할 때 : 1개의 변수에 여러 개의 값을 순차적으로 저장할 때

      2] 자바스크립트의 배열 : 객체이며 유용한 내장 메소드를 포함하고 있다.

3. 데이터 타입과 변수
   
   0] 시작하기에 앞서...

        1} 메모리에 값 저장하기

          1) 메모리 공간을 확보해야 할 메모리의 크기(byte)를 알아야 한다.
          -> 값의 종류(= 데이터의 종류, 데이터 타입(Data Type))에 따라 확보해야 할 메모리의 크기가 다르기 때문이다.

        2} C-family 언어(C, Java / 정적 타입(Static/Strong Type)의 언어) : 변수 선언 시 변수에 저장할 값의 종류를 사전에 타입 지정(Type annotation)하여야 한다.

        3} 동적 타입(Dynamic/Weak Type) 언어(자바스크립트) : 변수의 타입 지정(Type annotation) 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입 추론, Type Inference)된다.
        -> 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 있다. (변수 : 고정된 타입 X)

   1] 데이터 타입

        0} 들어가기에 앞서...

          1) 코드에서 사용되는 모든 데이터는 메모리에 저장하고 참조할 수 있어야 한다.

        1} 원시 타입(Primitive Data Type)

          0) 원시 타입의 값 : 변경 불가능한 값(immutable value) & 값에 의한 전달(pass-by-value)
   
          1) number

           1| 자바스크립트는 독특하게 실수(일반적으로 소수를 가리킨다.) 타입만 존재한다.

           2| 추가적으로 3가지 특별한 값들도 표현할 수 있다.

             1/ Infinity : 양의 무한대

             2/ -Infinity : 음의 무한대

             3/ NaN : 산술 연산 불가(not-a-number)

          2) string
          
           1| 사용

             1/ 텍스트 데이터를 나타낸다.

             2/ 표기법 : 작은 따옴표('')(가장 일반적인 표기법) 또는 큰 따옴표("") 안에 텍스트를 넣어 생성한다.

           2| 자바스크립트의 문자열 : 원시 타입 & 변경 불가능(immutable)

             1/ 예시
                var str = 'Hello';
                str = 'world'; 
                -> 변수 str은 문자열 'Hello'를 가리키고 있다가 문자열 'world'를 가리키도록 변경된 것이다.

             2/ 유사 배열 : 배열처럼 인덱스를 통해 접근할 수 있는 데이터

             3/ 변경 불가능(immutable)의 의미 : 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.
             -> 새로운 문자열을 재할당하는 것은 가능하다.

          3) boolean
           
           1| 불리언(boolean) 타입의 값 : 논리적 참, 거짓을 나타내는 true와 false뿐이다.

           2| 사용 : 조건문에서 자주 사용한다.
           -> 조건문은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어한다.

           3| false로 간주되는 것 : 비어있는 문자열, null, undefined, 숫자 0

          4) undefined

           1| undefined 타입의 값 : undefined
           -> 선언 이후 값을 할당하지 않은 변수는 undefined 값을 가진다.
           -> 이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어있다.)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다.
           -> 개발자가 변수의 값이 없다는 것을 명시하고 싶은 경우 : null을 할당한다.

          5) null

           1| null 타입의 값 : null
           -> 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 Null, NULL등과 다르다.

           2| 사용 : 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다.
           -> 이는 변수가 기억하는 메모리 어드레스의 참조 정보를 제거하는 것을 의미한다.
           -> 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행할 것이다.

           3| null 반환 : 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우. 명시적으로 null을 반환하기도 한다.

           4| typeof 연산자 

             1/ 정의 : 타입을 나타내는 문자열을 반환하는 연산자

             2/ 연산 : null이 아닌 object가 나온다.
             -> 이는 자바스크립트의 설계상의 오류이다.
             -> null 타입을 확인하는 방법 : 일치 연산자(===) 사용

          6) symbol

           1| 정의 : ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값

           2| 사용 목적 : 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해

           3| 호출 : 심볼은 Symbol 함수를 호출해 생성한다.
           -> 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.

        2} 객체 타입(Object type, Reference type)

          1) 객체

           1| 정의

             1/ 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재

             2/ 이름과 값을 가지는 데이터를 의미하는 프로퍼티(property)와 동작을 의미하는 메소드(method)를 포함할 수 있는 독립적 주체

            2| 자바스크립트

             1/ 원시 타입(Primitives)을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다.

             2/ 객체는 pass-by-reference(참조에 이한 전달) 방식으로 전달된다.

   2] 변수

        0} 들어가기에 앞서...

          1) 정의 : 프로그램에서 사용되는 데이터를 일정 기간 동안 기억하여 필요한 때에 다시 사용하기 위해 데이터에 고유의 이름인 식별자(identifier)를 명시한 것
   
          2) 변수명 : 변수에 명시한 고유한 식별자
   
          3) 변수값 : 변수로 참조할 수 있는 데이터
   
          4) 식별자 : 어떤 대상을 유일하게 식별할 수 있는 이름
         -> 식별자에는 변수명, 함수명, 프로퍼티명, 클래스명 등이 있다.

          5) 변수는 키워드(var, let, const)를 사용하여 선언하고 할당 연산자를 사용해 값을 할당하며 식별자인 변수명을 사용해 변수에 저장된 값을 참조한다.

        1} 변수의 선언

          1) 변수명(식별자(identifier)) 명명 규칙
   
            1| 반드시 영문자(특수문자 제외), jnderscore( _ ), 또는 달러 기호($)로 시작하여야 한다.
            이어지는 문자에는 숫자(0-9)도 사용할 수 있다.

            2| 사용할 수 있는 문자 : "A"~"Z"(대문자)와 "a"~"z"(소문자)
            -> 자바스크립트는 대/소문자를 구별하기 때문이다.

          2) 선언 : var 키워드 사용한다.

            1| var 키워드를 사용한다.

            2| 할당 연산자 : 등호(=, equal sign)

            3| 선언하지 않은 변수에 접근하면 ReferenceError가 발생한다.

        2} 변수의 중복 선언

          1) var 키워드로 선언한 변수는 중복 선언이 가능하다.
   
          2) 부작용 : 동일한 변수명이 선언되어 있는 것을 모르고 변수를 중복 선언했다면 의도치 않게 변수의 값을 변경한다.
          -> 사용하지 않는 것이 좋다.

        3} 동적 타이핑(Dynamic Typing)

          1) 정의 : 같은 변수에 여러 타입의 값을 할당할 수 있다.
          
        4} 변수 호이스팅(Variable Hoisting)

          1) 호이스팅

            0| 자바스크립트는 모든 선언문이 호이스팅(Hoisting)된다.

            1| 정의 : 모든 선언문(var 선언문이나 function 선언문 등)이 해당 Scope의 선두로 옮겨지는 것처럼 동작하는 특성
            -> 자바스크립트는 모든 선언문이 선언되기 이전에 참조 가능하다.

          2) 변수 생성

            1| 선언 단계(Declaration phase) : 변수 객체(Variable Object)에 변수를 등록한다.
            -> 변수 객체 : 스코프가 참조하는 대상

            2| 초기화 단계(Initialization phrase) : 변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다.
            -> 변수는 undefined로 초기화된다.
            => 선언 단계와 초기화 단계는 한 번에 이루어진다.

            3| 할당 단계(Assignment phase) : undefined로 초기화된 변수에 실제값을 할당한다.

            4| 변수 호이스팅 : 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러기 발생하지 않고 undefined를 반환하는 현상

          3) 스코프

            1| 함수 레벨 스코프(Function-level scope) : 함수 내에 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.
            -> 함수 내부에서 선언한 변수 : 지역 변수
            -> 함수 외부에서 선언한 변수 : 전역 변수

            2| 블록 레벨 스코프(Block-level scope) : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

        5} var 키워드로 선언된 변수의 문제점

          1) var 키워드로 선언된 변수의 특징

            1| 함수 레벨 스코프(Function-level scope)

                1/ 전역 변수의 남발

                2/ for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.

            2| var 키워드 생략 허용

                1/ 의도하지 않은 변수의 전역화

            3| 중복 선언 허용

                1/ 의도하지 않은 변수값 변경

            4| 변수 호이스팅

                1/ 변수를 선언하기 전에 참조가 가능하다.

          2) 대부분의 문제는 전역 변수로 인해 발생한다.

            1| 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될지 파악하기 힘들다.

            2| 복잡성이 증가한다.

         -> 변수의 유효 범위(scope)는 좁을수록 좋다.
         -> ES6는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.

4. 연산자

   1] 표현식과 연산자

     1} 표현식과 값
     
       1) 표현식과 값은 동등한 관계이다.
       -> 동치(Equivalent)

       2) 표현식은 값처럼 사용할 수 있다.
       -> 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.
     
   2] 문과 표현식

     1} 자바스크립트의 모든 코든느 문 또는 표현식이다.

     2} 역할

       1) 표현식의 역할 : 값을 생성하는 것

       2) 문의 역할 : 표현식으로 생성한 값을 사용해 컴퓨터에게 명령을 내리는 것

     3} 문

       1) 표현식인 문

         1| 예시 : 할당문(그 자체가 표현식인 문이다.)

       2) 표현식이 아닌 문

         1| 예시 : 선언문(값으로 평가될 수 없다.)

   3] 연산자란?

     1} 정의 : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다.

     2} 피연산자(Operand) : 연산의 대상

     3} 연산자와 표현식

       1) 피연산자 : 표현식이다.
       -> 피연산자도 평가되어 하나의 값이 되기 때문이다.

       2) 연산자 표현식 : 표현식이다.
       -> 연산자 표현식 : 피연산자를 연산자와 결합한 것

     4} 연산자와 피연산자

       1) 연산자 : "값을 만든다"라는 동사의 역할
   
       2) 피연산자 : "값"이라는 명사의 역할

   4] 산술 연산자

     0} 들어가기에 앞서...

       1) 정의 : 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
   
       2) 산술 연산을 할 수 없는 경우 : NaN을 반환하다.

     1} 이항 산술 연산자

       3) 연산 : 2개의 피연산자를 대상으로 연산하여 숫자 타입의 값을 만든다.

       4) 피연산자의 값을 변경하는 부수 효과(Side effect)가 없다.
       -> 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 단지 새로운 값을 만들 뿐이다.

       5) 종류

         1| + : 덧셈

         2| - : 뺄셈

         3| * : 곱셈

         4| / : 나눗셈

         5| % : 나머지

     2} 단항 산술 연산자

       6) 연산 : 1개의 피연산자를 대상으로 연산한다.
   
       7) 피연산자의 값을 변경하는 부수 효과가 있다.
       -> 증가/감소 연산을 하면 피연산자의 값이 바뀐다.

       8) 종류

         1| ++ : 증가

         2| -- : 감소

         3| + : 어떠한 효과도 없다.(부수 효과 X)
         -> 음수를 양수로 반전하지도 않는다.

         4| - : 양수를 음수로 음수를 양수로 반전한 값을 반환한다. (부수 효과 X)

       9)  전위 증가/감소 연산자(Prefix increment/decrement operator) & 후위 증가/감소 연산자(Postfix increment/decrement operator)

         1| 전위 증가/감소 연산자 : 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.

         2| 후위 증가/감소 연산자 : 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.

     3} 문자열 연결 연산자

       10) + 연산자 : 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
       (그 외의 경우는 덧셈 연산자로 동작한다.)

       11) + / - 단항 연산자도 암묵적 타입 변환 발생이 가능하다.

   5] 할당 연산자(Assignment Operator)

     1} 정의 : 우항에 있는 피연자의 평가 결과를 좌항에 있는 변수에 할당한다.

     2} 부수 효과 : 할당 연산자는 변수에 값을 할당하므로 부수 효과 O

     3} 종류

       12) =
   
         1| 사례 : x = y

         2| 동일 표현 : x = y

       13) +=

         1| 사례 : x += y

         2| 동일 표현 : x = x + y

       14) -=

         1| 사례 : x -= y

         2| 동일 표현 : x = x - y

       15) *=

         1| 사례 : x *= y

         2| 동일 표현 : x = x * y

       16) /=

         1| 사례 : x /= y

         2| 동일 표현 : x = x / y

       17) %=

         1| 사례 : x %= y

         2| 동일 표현 : x = x % y

     4} 표현식 : 할당 연산은 하나의 값으로 평가되는 표현식이다.
     -> 할당 표현식은 할당된 값으로 평가된다.

   6] 비교 연산자(Comparison Operator)

     0} 들어가기에 앞서...

       1) 반환값 : 좌항과 우항의 피연산자를 비교하여 불리언 값을 반환한다.
   
       2) 사용 : 제어문(if 문, for 문 등)의 조건식에서 주로 사용한다.

     1} 동등 / 일치 비교 연산자

       1) 종류

         1| ==

             1/ 의미 : 동등 비교

             2/ 사례 : x == y

             3/ 설명 : x와 y의 값이 같음

             4/ 좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교한다.

         2| ===

             1/ 의미 : 일치 비교

             2/ 사례 : x === y

             3/ 설명 : x와 y의 값과 타입이 같음

             4/ 주의사항 : NaN, 숫자 0
             -> NaN의 정의 : 자신과 일치하지 않은 유일한 값
             -> NaN의 조사 방법 : 빌트인 함수 isNaN을 사용한다.

         3| !=

             1/ 의미 : 부등 비교

             2/ 사례 : x != y

             3/ 설명 : x와 y의 값이 다름

         4| !==

             1/ 의미 : 불일치 비교

             2/ 사례 : x !== y

             3/ 설명 : x와 y의 값과 타입이 다름

     2} 대소 관계 비교 연산자

       1) 반환값 : 피연산자의 크기를 비교하여 불리언 값을 반환한다.
   
       2) 종류

         1| >

             1/ 예제 : x > y

             2/ 설명 : x가 y보다 크다.

         2| <

             1/ 예제 : x < y

             2/ 설명 : x가 y보다 작다.

         3| >=

             1/ 예제 : x >= y

             2/ 설명 : x가 y보다 같거나 크다.

         4| <=

             1/ 예제 : x <= y

             2/ 설명 : x가 y보다 같거나 크다.

   7] 삼항 조건 연산자

     1} 반환값 : 조건식의 평가 결과에 따라 반환할 값을 결정한다.

     2} 자바스크립트의 삼항 연산자 : 삼항 조건 연산자가 유일하다.

     3} 부수 효과 : 부수 효과는 없다.

     4} 삼항 조건 연산자 표현식
     
     -> 조건식 ? 조건식이 true일 떄 반환할 값 : 조건식이 false일 때 반환할 값

       1) 조건식 : 물음표(?) 앞의 첫번째 피연산자, 불리언 타입의 값으로 평가될 표현식

         1| 조건식의 평가 결과가 불리언 값이 아닐 경우 : 불리언 값으로 암묵적 타입 변환된다.

         2| 조건식이 참인 경우 : 콜론(:) 앞의 두번째 피연산자가 평가되어 반환된다.

         3| 조건식이 거짓인 경우 : 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다.

     5} 삼항 조건 연산자 표현식 : 값으로 평가할 수 있는 표현식
     -> 삼항 조건 연산자식은 다른 표현식의 일부가 될 수 있어 매우 유용하다.

   8] 논리 연산자(Logical Operator)
   
     1} 연산 : 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.

     2} 종류

       2) ||

         1| 의미 : 논리합(OR)

       3) &&

         1| 의미 : 논리곱(AND)

       4) !

         1| 의미 : 부정(NOT)

     3} 논리 부정(!) 연산자

       5) 반환값 : 언제나 불리언 값을 반환한다.

       6) 피연산자 : 반드시 불리언 값일 필요는 없다.
       -> 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.

     4} 논리합(||) 연산자와 논리곱(&&) 연산자

       7) 연산 결과 : 일반적으로 불리언 값을 반환하지만 반드시 반환해야 하는 것은 아니다.

       8) 반환 : 언제나 피연산자 중 어느 한쪽 값을 반환한다.

   9] 쉼표(,) 연산자

     1} 반환 : 왼쪽 피연산자부터 차례대로 피연산자를 평가 
     
     -> 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

   10] 그룹((...)) 연산자

     1} 평가 : 그룹 내의 표현식을 최우선으로 평가한다.

     2} 역할 : 연산자의 우선 순위를 1순위로 높일 수 있다.

   11] typeof 연산자

     1} 반환 : 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다.

     => 여기서 말하는 문자열 : 7개의 데이터 타입과 일치하지 않다.
     
     2} typeof 연산자

       1) 반환 : 7가지 문자열("string", "number", "boolean", "undefined", "symbol", "object", "function"(함수)) 중 하나를 반환한다.
       -> "null"을 반환하는 경우는 없다.

       2) null
   
         1| 연산 : null이 아닌 "object"를 반환한다는 것이다.
         -> 자바스크립트의 첫 번째 버전에서 이렇게 설계된 것을 현재의 버전에 반영하지 못하고 있기 때문이다.

         2| 확인 : typeof 연산자를 사용하지 않고 일치 연산자(===)를 사용하도록 한다.

       3) 주의사항 : 선언하지 않은 식별자를 typeof 연산자로 연산해보면 ReferenceError가 발생하지 않고 "undefined"를 반환한다.

5. 제어문
   
   0] 들어가기에 앞서...

     1} 사용 : 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때

     2} 코드 실행 : 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.
     -> 제어문은 코드의 실행 순서를 인위적으로 제어할 수 있다.

   1] 블록문(Block statement/Compound statement)

     1} 정의 : 0개 이상의 문들을 중괄호로 묶은 것
     (코드 블록 또는 블록이라고 부르기도 한다.)

     2} 자바스크립트 : 블록문을 하나의 단위로 취급한다.

     3} 사용 : 단독으로 사용할 수 있으나 일반적으로 제어문이나 함수 선언문 등에서 사용한다.

     4} 세미콜론 : 블록문은 세미콜론(;)을 붙이지 않는다.

   2] 조건문

     0} 들어가기에 앞서...

       1) 정의 : 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다.
   
       2) 조건문과 표현식 : 조건문은 불리언 값으로 평가될 수 있는 표현식이다.

     1} if..else 문

       1) 정의 : 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과(논리적 참, 거짓)에 따라 실행할 코드 블록을 결정한다.

       2) 평가 결과

         1| 불리언 값인 경우
         
             1/참(true)일 경우 : if 문 다음의 코드 블록이 실행된다.

             2/ 거짓(false)일 경우 : else 문 다음의 코드 블록이 실행된다.

         2| 불리언 값이 아닌 경우 : 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다.

       3) else if 문과 else 문

         1| else if 문 : 조건식을 추가하고 싶을 때 사용한다.

         2| 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다.

         3| if 문과 else 문 : 2번 이상 사용할 수 없다.
         
         4| else if 문 : 여러 번 사용할 수도 있다.

       4) 코드 블록 : 코드 블록 내의 문이 하나뿐이라면 중괄홀를 생략할 수 있다.
   
       5) 대부분의 if...else 문은 연산자에서 살펴본 삼항 조건 연산자로 바꿔쓸 수 있다.

     2} switch 문

       1) 정의 : switch 문의 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다.
   
       2) case 문
   
         1|상황(case)을 의미하는 표현식을 지정하고 콜론으로 마친다. 

         2| 그 뒤에 실행할 문들을 위치시킨다.

         3| 표현식과 일치하는 표현식을 갖는다.

         4| case문이 없을 경우 : 실행 순서는 default문으로 이동한다.
         -> default문 : 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다.

       3) 표현식 : 불리언 값보다는 문자열, 숫자 값인 경우가 많다.

       4) 사용 : 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.
   
       5) break 문
   
         1| 코드 블록에서 탈출하는 역할을 수행한다.

         2| break 문이 없을 때 : case 문의 표현식과 일치하지 않더라도 실행 순서는 다음 case 문으로 연이어 이동한다.

         3| break 생략 : default 문에는 break 문을 생략하는 것이 일반적이다.
         -> default 문은 switch 문의 가장 마지막에 위치하므로 default 문의 실행이 종료하면 switch 문을 빠져나가므로 별도로 break 문이 필요없다.

       6) if...else 문과 switch 문

         1| switch 문 : 다양한 키워드를 사용해야 하고 문법도 복잡하다.
         -> if...else 문으로 해결할 수 있다면 if...else 문을 사용하는 편이 좋다.

         2| 가독성 : if...else 문의 가독성 < switch 문의 가독성
         -> switch 문을 사용하는 편이 좋다.

   3] 반복문(Loop statement)

     0} 들어가기에 앞서...

       1) 실행
         
         1| 주어진 조건식(conditional expression)의 평가 결과가 참인 경우 코드 블럭을 실행한다.

         2| 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다.

         3| 이는 조건식이 거짓일 때까지 반복된다.

     1} for 문

       1) 실행 : 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다.

       2) 가장 일반적으로 사용되는 반복문이다.

       3) 실행 순서

         1| for 문을 실행하면 가장 먼저 초기화식이 실행된다.
         -> 초기화식은 단 한 번만 실행된다.

         2| 초기화식의 실행이 종료되면 조건식으로 실행 순서가 이동한다.

         3| 조건식의 평가 결과가 true인 경우 : 실행 순서가 코드 블록으로 이동하여 실행된다.
         -> 주의 사항 : 증감문으로 실행 순서가 이동하는 것이 아니라 코드 블록으로 실행 순서가 이동한다.

         4| 코드 블록의 실행이 종료되면 증감식으로 실행 순서가 이동한다.

         5| 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다.
         -> 주의 사항 : 초기화식으로 실행 순서가 이동하는 것이 아니라 조건식으로 실행 순서가 이동한다.

         6| 조건식의 평가 결과가 false인 경우 : for 문의 실행이 종료된다.

       4) 선언

         1| 옵션 : 초기화식, 조건식, 증감식은 반드시 사용할 필요는 없다.

         2| 어떤 식도 선언하지 않은 경우 : 무한 루프가 된다.

       5) 중첩 : 중첩 가능

     2} while 문

       1) 실행

         1| 주어진 조건식의 평가 결과가 불리언 값인 경우 
         
             1/ 주어진 조건식의 평가 결과가 참인 경우 : 코드 블록을 계속해서 반복 실행한다.

             2/ 주어진 조건식의 평가 결과가 거짓인 경우 : 실행을 종료한다.

         2| 주어진 조건식의 평가 결과가 불리언 값이 아닌 경우 : 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다.

       2) 무한루프

         1| 주어진 조건식의 평가 결과가 언제나 참이면 무한루프가 된다.

         2| 탈출 : 코드 블록 탈출 조건을 if 문에 부여하고 break 문으로 코드 블록을 탈출한다.

     3} do...while 문

       1) 평가 : 코드 블록을 실행하고 조건식을 평가한다.
       -> 코드 블록은 무조건 한 번 이상 실행된다.

   4] break 문

     1} 탈출
     
       1) 레이블 문, 반복문(for, for...in, for...of, while, do...while) 또는 switch 문의 코드 블록을 탈출한다.

       2) 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용할 경우 : SyntaxError(문법 에러)가 발생한다.

     2} 레이블 문(Label statement)

       1) 정의 : 식별자가 붙은 문

       2) 사용 목적 : 프로그램의 실행 순서를 제어하기 위해

       3) 예시 : switch 문의 case 문과 default 문
   
       4) 탈출 : break 문에 레이블 식별자를 지정한다.
   
       5) 권장

         1| 중첩된 for 문을 외부로 탈출할 때 : 레이블 문은 유용하다. 

         2| 그 외의 경우 : 레이블 문은 일반적으로 권장하지 않는다.
         -> 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.
   
     3} 중첩된 for 문 
     
       1) 중첩된 for 문의 내부 for 문에서 break 문을 실행하면 내부 for 문으로 진입한다.
       -> 이때 내부 for 문이 아닌 외부 for 문을 탈출하려면 레이블 문을 사용한다.

     4} 사용 : 레이블 문 뿐만이 아니라 반복문, switch 문에서도 사용할 수 있다.

     -> 이 경우에는 break 문에 레이블 식별자를 지정하지 않는다.

     5} break 문은 반복문을 더 이상 진행하지 않아도 될 때 불필요한 반복을 회피할 수 있어 유용하다.

   5] continue 문

     1} 실행
     
       1) 반복문(for, for...in, for...of, while, do...while)의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다.

       2) if 문 내에서 실행해야 할 코드

         1| if 문 내에서 실행해야 할 코드가 한 줄인 경우 : continue 문을 사용했을 때보다 간편하며 가독성도 좋다.

         2| if 문 내에서 실행해야 할 코드가 길 경우 : 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다.

     2} 탈출 : break 문처럼 반복문을 탈출하지는 않는다.        

6. 타입 변환과 단축 평가

   1] 타입 변환이란?

     1} 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting)
     
       1) 정의 : 개발자에 의해 의도적으로 값의 타입을 변환하는 것

       2) 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.

     2} 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)
     
       1) 정의 : 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것

       2) 변수 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러 없이 평가하기 위해 기존 값을 바탕으로 새로운 타입의 값을 만들어 단 한 번 사용하고 버린다.

       3) 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발의 의지가 코드에 명백히 나타나지 않는다.
       
       4) 타입 변환된 값으로 표현식의 평가 : 어떻게 평가될 것인지 예측 가능해야 한다.
       -> 만약 예측하지 못하거나 예측한 내용이 결과와 일치하지 않다면 버그를 생산할 가능성이 높아진다.

   2] 암묵적 타입 변환

     0} 들어가기에 앞서...

       1) 자바스크립트 엔진은 표현식을 평가할 때 문맥, 즉 컨텍스트(Context)에 고려하여 암묵적 타입 변환을 실행한다.
       -> 표현식을 평가할 때 문맥(context)에 부합하지 않는 다양한 상황이 발생할 수 있다.
       -> 자바스크립트 : 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다.

     1} 문자열 타입으로 변환

       1) + 연산자 
   
         1| 피연산자 중 하나 이상이 문자열일 때 문자열 연결 연산자로 동작한다.

         2| 문자열 연결 연산자
             1/ 역할 : 문자열 값을 만드는 것이다.

             2/ 피연산자 : 문맥(context)상 문자열 타입이여야 한다.

       2) 자바스크립트 엔진

         1| 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.

         2| 연산자식의 피연산자(피연산자도 표현식이다.)만이 암묵적 타입 변환의 대상이 되는 것은 아니다.

         3| 표현식을 평가할 때, 문맥(context)에 부합하도록 암묵적 타입 변환을 실행한다.

     2} 숫자 타입으로 변환

       1) 산술 연산자
   
         1| 역할 : 숫자 값을 만드는 것이다.

         2| 피연산자 : 문맥(context)상 숫자 타입이여야 한다.
      
       2) 자바스크립트 엔진

         1| 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 수자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.

         2| 피연산자를 숫자 타입으로 변환할 수 없는 경우 : 산술 연산을 수행할 수 없으므로 NaN을 반환한다.

         3| 비교 연산자

             1/ 역할 : 불리언 값을 만드는 것이다.

             2/ 피연산자의 크기를 비교하므로 피연산자는 컨텍스트 상 숫자 타입이여야 한다.

             3/ 자바스크립트 엔진이 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때
       3) 비교 연산자

         1| 역할 : 불리언 값을 만드는 것이다.

         2| 피연산자의 크기를 비교하므로 피연산자는 컨텍스트 상 숫자 타입이여야 한다.

         3| 자바스크립트 엔진

             1/ 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때
             -> + 단항 연산자 : 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다.

         4| 변환

             1/ 0으로 변환 : 빈 문자열(''), 빈 배열([]), null, false

             2/ 1로 변환 : true

             3/ 주의 사항 : 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다는 것이다.

     3} 불리언 타입으로 변환

       1) 자바스크립트 엔진

         1| 제어문의 조건식을 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.

         2| 불리언 타입이 아닌 값을 Truthy 값(참으로 인식할 값) 또는 Falsy 값(거짓으로 인식할 값)으로 구분한다.
         -> Truthy 값은 true로, Falsy 값은 false로 변환된다.

         3| 불리언 값으로 평가되어야 할 컨텍스트에서 false로 평가되는 Falsy 값의 종류

             1/ false

             2/ undefined

             3/ null

             4/ 0, -0

             5/ NaN

             6/ '' (빈 문자열)

         4| 불리언 값으로 평가되어야 할 컨텍스트에서 true로 평가되는 Truthy 값 : Falsy 값 이외의 값

   3] 명시적 타입 변환

     1} 문자열 타입으로 변환

       1) 문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법

         1| String 생성자 함수를 new 연산자 없이 호출하는 방법

         2| Object.prototype.toString 메소드를 사용하는 방법

         3| 문자열 연결 연산자를 이용하는 방법

     2} 숫자 타입으로 변환

       1) 숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법

         1| Number 생성자 함수를 new 연산자 없이 호출하는 방법

         2| parselnt, parseFloat 함수를 사용하는 방법 (문자열만 변환 가능)

         3| 단항 연결 연산자를 이용하는 방법

         4| 산술 연산자를 이용하는 방법

     3} 불리언 타입으로 변환

       1) 불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

         1| Boolean 생성자 함수를 new 연산자 없이 호출하는 방법

         2| ! 부정 논리 연산자를 두 번 사용하는 방법

   4] 단축 평가(Short-Circuit evaluation)

     1} 논리곱 연산자(&&)

       1) 반환 : 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다.

       2) 진행 : 오른쪽에서 왼쪽으로 평가가 진행된다.

     2} 논리합 연산자(||)

       1) 반환 : 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.

       2) 진행 : 오른쪽에서 왼쪽으로 평가가 진행된다.

     3} 정의 : 논리 평가를 결정한 피연산자의 평가 결과를 그대로 반환하는 것

     4} 단축 평가 표현식

       1) true || anything

         1| 평가 결과 : true

       2) false || anything

         1| 평가 결과 : anything

       3) true && anything 

         1| 평가 결과 : anything

       4) false && anything
   
         1| 평가 결과 : false

     5} 단축 평가가 유용하게 사용되는 상황

       1) 객체가 null인지 확인하고 프로퍼티를 참조할 때

         1| 객체가 null인 경우 : 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다.
         -> 단축 평가를 사용하면 에러를 발생시키지 않는다.

         2| 함수의 인수(argument)를 초기화할 때 : 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다.
         -> 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.

7. 프로토타입
   1] 프로토타입 객체

     1} 자바스크립트 : 프로토타입 기반 객체지향 프로그래밍 언어
     -> 클래스 없이(Class-less)도 (ECMAScript 6에서 클래스가 추가되었다) 객체를 생성할 수 있다.

     2} 자바스크립트의 객체 생성 방법

       1) 자바스크립트의 모든 객체 : 자신의 부모 역할을 담당하는 객체와 연결되어 있다.
       -> 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다.

       2) Prototype(프로토타입) 객체 또는 Prototype(프로토타입) : 부모 객체
       -> 사용 목적 : 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해

     3} ECMAScript spec

       1) 자바스크립트의 모든 객체 : [[Prototype]]이라는 인터널 슬롯(internal slot)를 가진다.

       2) [[Prototype]]의 값 : null 또는 객체이며 상속을 구현하는데 사용된다.
     
         1| 객체 : Prototype(프로토타입) 객체이다.

         2| __proto__accessor property로 접근할 수 있다.

         3| __proto__ 프로퍼티에 접근한 경우 : 내부적으로 Object.getPrototypeOf가 호출되어 프로토타입 객체를 반환한다.

       3) [[Prototype]] 객체의 데이터 프로퍼티 : get 액세스를 위해 상속되어 자식 객체의 프로퍼티처럼 사용할 수 있다.
       -> set 액세스는 허용되지 않는다.

       4) student 객체 : __proto__ 프로퍼티로 자신의 부모 객체(프로토타입 객체)인 Object.prototype을 가리키고 있다.

     4} 객체를 생성할 때 프로토타입은 결정된다.

     5} 결정된 프로토타입 객체 : 다른 임의의 객체로 변경할 수 있다.

     => 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다.
     -> 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.

   2] [[Prototype]] vs prototype 프로퍼티

     1} 모든 객체 : 자신의 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯(internal slot)을 갖으며 상속을 위해 사용된다.

     -> 함수 객체 : 일반 객체와는 달리 prototype 프로퍼티도 소유하게 된다.

     -> 주의 사항 : prototype 프로퍼티는 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯은 다르다는 것이다.

     2} [[Prototype]]

       1) 함수를 포함한 모든 객체가 가지고 있는 인터널 슬롯이다.

       2) 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키며 함수 객체의 경우 Function.prototype를 가리킨다.
   
     3} prototype 프로퍼티

       1) 함수 객체만 가지고 있는 프로퍼티이다.

       2) 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 부모 역할을 하는 개체(프로토타입 객체)를 가리킨다.

   3] constructor 프로퍼티

     1} 정의 : 객체의 입장에서 자신을 생성한 객체를 가리킨다.

     2} 프로토타입 객체는 constructor 프로퍼티를 갖는다.

   4] Prototype chain

     0} 들어가기에 앞서...

       1) 정의 : 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색하는 것

     1} 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인

       1) 객체 생성 방법

         1| 객체 리터럴

         2| 생성자 함수

         3| Object() 생성자 함수

       2) 객체 리터럴 방식으로 생성된 객체 : 내장 함수(Built-in)인 Object() 생성자 함수로 객체를 생성하는 것을 단순화시킨 것
       
       3) 자바스크립트 엔진 : 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object() 생성자 함수(함수이므로 prototype 프로퍼티가 있다.)를 사용하여 객체를 생성한다.

       4) 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 Object.prototype이다.

     2} 생성자 함수로 생성된 객체의 프로토타입 체인

       1) 생성자 함수 정의
       -> 생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.

         1| 함수를 정의하는 방식 .

             1/ 함수선언식(Function declaration) : 자바스크립트 엔진이 내부적으로 기명 함수표현식으로 변환한다.
             -> 함수 리터럴 방식을 사용한다.

             2/ 함수표현식(Function expression) : 함수 리터럴 방식을 사용한다.

             3/ Function() 생성자 함수

         2| 3가지 함수를 정의하는 방식
         
             1/ Function() 생성자 함수를 통해 함수 객체를 생성한다.

             2/ 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 prototype 객체는 Function.prototype이다.
             -> 생성자 함수도 함수 객체이므로 생성자 함수의 prototype 객체는 Function.prototype이다.

         3| 함수 리터럴 방식 : Function() 생성자 함수로 함수를 생성하는 것을 단순화시킨 것

       2) 객체를 생성하는 방식

         1| 객체 리터럴

             1/ 엔진의 객체 생성 : Object() 생성자 함수

             2/ 인스턴스의 prototype 객체 : Object.prototype

         2| Object() 생성자 함수

             1/ 엔진의 객체 생성 : Object() 생성자 함수

             2/ 인스턴스 prototype 객체 : Object.prototype

         3| 생성자 함수

             1/ 엔진의 객체 생성 : 생성자 함수

             2/ 인스턴스의 prototype 객체 : 생성자 함수 이름.prototype

         4| foo 객체의 프로토타입 객체 Person.prototype 객체와 Person() 생성자 함수의 프로토타입 객체인 Fuction.prototype의 프로토타입 객체는 Object.prototype 객체이다.

         5| 프로토타입 체인의 종점(End of prototype chain) : Object.prototype 객체
         -> 모든 객체의 부모 객체인 Object.prototype 객체에서 프로토타입 체인이 끝나기 때문이다.

   5] 프로토타입 객체의 확장

     1} 프로토타입 객체 : 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다.
     -> 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.

     2} Person.prototype 객체 : 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다.

   6] 원시 타입(Primitive data type)의 확장

     1} 원시 타입은 객체가 아니므로 프로퍼티나 메소드를 가질 수 없다.
     -> String 객체의 프로토타입 객체 String.prototype에 메소드를 추가하면 원시 타입, 객체 모두 메소드를 사용할 수 있다.
     
     2} 원시 타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.

     3} 프로토타입 객체(String.prototype, Number.prototype, Array.prototype 등 : Built-in object(내장 객체)의 Global objects(Standard Built-in Objects)인 String, Number, Array 객체 등이 가지고 있는 표준 메소드에 정의되어 있다.) 또한 Object.prototype를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.

     4} 자바스크립트 : 표준 내장 객체의 프로토 객체에 개발자가 정의한 메소드의 추가를 허용한다.

   7] 프로토타입 객체의 변경

     1} 객체를 생성할 때 프로토타입은 결정된다.

     2} 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다.

     => 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다.
     -> 객체의 상속을 구현할 수 있다.

     3} 프로토타입 객체 변경 시 발생하는 일

       1) 프로토타입 객체 변경 시점 이전에 생성된 객체 기존 프로토타입 객체를  [[Prototype]]에 바인딩한다.

       2) 프로토타입 객체 변경 시점 이후에 생성된 객체 변경된 프로토타입 객체를  [[Prototype]]에 바인딩한다.

       3) 단계

         1| constructor 프로퍼티는 Person() 생성자 함수를 가리킨다.

         2| 프로토타입 객체 변경 후, Person() 생성자 함수의 Prototype 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 Person.prototype.constructor 프로퍼티도 삭제되었다. 
         -> 따라서 프로토타입 체인에 의해 bar.constructor의 값은 프로토타입 체이닝에 의해 Object.prototype.constructor 즉 Object() 생성자 함수가 된다.

   8] 프로토타입 체인 동작 조건

     1} 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다.

     2} 객체의 프로퍼티에 값을 할당하는 경우 : 프로토타입 체인이 동작하지 않는다.

     -> 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.
8. 스코프

   1] 스코프란?

     1} 정의 : 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙

     2} 식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖는다.

     3} 스코프가 없는 경우 : 같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다.

   2] 스코프의 구분

     1} 스코프의 구분

       1) 전역 스코프(Global scope) : 코드 어디에서든지 참조할 수 있다.

       2) 지역 스코프(Local scope or Function-level scope) : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.

     2} 변수

       1) 전역 변수(Global variable) : 전역에서 선언된 변수이며 어디에든 참조할 수 있다.

       2) 지역 변수(Local variable) : 지역(함수) 내에서 선언된 변수이며 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.

   3] 자바스크립트 스코프의 특징

     1} 함수 레벨 스코프(function-level scope) : 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것

     -> 단, ECMAScript 6에서 도입된 let keyword를 사용하면 블록 레벨 스코프를 사용할 수 있다.

   4] 전역 스코프(Global scope)

     1} 선언 : 전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 스코프를 갖는 전역 변수가 된다.

     2} var 키워드로 선언한 전역 변수 : 전역 객체(Global Object) window의 프로퍼티

     3} 자바스크립트 : 특별한 시작점(Entry point)이 없어서 위 코드와 같이 전역에 변수나 함수를 선언하기 쉽다.

     -> 전역 변수를 남발하게 하는 문제를 야기시킨다.

     4} 사용 : 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 사용을 억제하여야 한다.

   5] 비 블록 레벨 스코프(Non block-level scope) 

     1} 자바스크립트 : 변수 x가 코드 블록 내에서 선언되지만 블록 레벨 스코프를 사용하지 않으므로 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다할지라도 모두 전역 스코프를 갖게 된다. 

     -> 변수 x : 전역 변수

   6] 함수 레벨 스코프(Function-level scope) 

     1} 자바스크립트 : 함수 레베 ㄹ스코프를 사용한다.

     -> 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다.

     2} 전역변수 x와 지역변수 x가 중복 선언된 경우

       1) 전역 영역과 지역 영역

         1| 전역 영역 : 전역변수만이 참조 가능하다.

         2| 지역 영역 : 전역과 지역 변수 모두 참조 가능하다.

       => 지역변수를 우선하여 참조한다.

       -> 전역변수의 값도 변경할 수 있다.

       2) 내부 함수 : 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다.

     3} 중첩 스코프 : 가장 인접한 지역을 우선하여 참조한다.

   7] 렉시컬 스코프

     1} 정의 : 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.

     2} 자바스크립트 : 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다.

     -> 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다.

   8] 암묵적 전역(implicit global)

     1} 정의 : 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다.

     2} 식별자는 변수가 아니다.
     
     -> 변수 선언 없이 단지 전여 객체의 프로퍼티로 추가되었을 뿐이다.

     -> 변수 호이스팅 X

     -> 식별자 : 단지 프로퍼티
     => delete 연산자로 삭제할 수 있다.

     -> 전역 변수 : 프로퍼티이지만 delete 연산자로 삭제할 수 없다.

   9] 최소한의 전역변수 사용

     1} 전역변수 사용을 최화하는 방법 중 하나 : 애플리케이션에서 전역변수 사용을 위해 전역변수 객체 하나를 만들어 사용하는 것

   10] 즉시실행함수를 이용한 전역변수 사용 억제

     1} 전역변수 사용을 억제하기 위해 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다.

     -> 이 방법을 사용하면 전역 변수를 만들지 않으므로 라이브러리 등에 자주 사용된다.

     -> 즉시 실행 함수 : 즉시 실행되고 그 후 전역에서 바로 사라진다.

## ECMAScript6

1. let, const와 블록 레벨 스코프

   0] 시작하기에 앞서...

     1} var 키워드로 선언된 변수의 특징

       1) 함수 레벨 스코프(Function-level scope)

         1| 함수의 코드 블록만을 스코프로 인정한다.
         => 전역 함수 외부에서 생성한 변수는 모두 전역 변수이다.
         -> 전역 변수를 남발할 가능성을 높인다.

       2) var 키워드 생략 허용

         1| 암묵적 전역 변수를 양산할 가능성이 크다.

       3) 변수 중복 선언 허용

         1| 의도하지 않은 변수값의 변경이 일어날 가능성이 크다.

       4) 변수 호이스팅

         1| 변수를 선언하기 이전에 참조할 수 있다.

   1] let

     1} 블록 레벨 스코프

       1) 자바스크립트 : ES6는 블록 레벨 스코프를 따르는 변수를 선언하기 위해 let 키워드를 제공한다.

     2} 변수 중복 선언 금지

       1) var 키워드 : 동일한 이름을 갖는 변수를 중복해서 선언할 수 있다.

       2) let 키워드 : 동일한 이름을 갖는 변수를 중복해서 선언할 수 없다.
       -> 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생한다.

     3} 호이스팅

       1) let 키워드로 선언된 변수
   
         1| 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.
         -> 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다.

         2| 선언 단계와 초기화 단계가 분리되어 진행된다.
         -> 스코프에 변수를 등록(선언 단계)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다.

         3| 초기화 이전에 변수에 접근하려고 하는 경우 : 참조 에러(ReferenceError)가 발생한다.
         -> 변수가 아직 초기화되지 않았기 때문이다.
         -> 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다.

         4| 스코프 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다.

         5| 일시적 사각지대(Temporal Dead Zone; TDZ) : 스코프의 시작 지점부터 초기화 시작 지점까지의 구간

     4} 클로저

       1) 자바스크립트의 함수 레벨 스코프로 인하여 for 루프의 초기화 식에 사용된 변수가 전역 스코프를 갖게 되어 발생하는 문제를 회하기 위해 클로저를 활용한 방법이다.
       -> ES6의 let 키워드를 for 루프의 초기화 식에 사용하면 클로저를 사용하지 않아도 위 코드와 동일한 동작을 한다.

     5} 전역 객체와 let

       1) 전역 객체(Global Object)
   
         1| 정의
         
             1/모든 객체의 유일한 최상위 객체

             2/ window 객체 in Browser-side

             3/ global 객체 in Server-side(Node.js)

         2| var 키워드로 선언된 변수 : 전역 객체의 프로퍼티가 된다.

         3| let 키워드로 선언된 변수 : 보이지 않는 개념적인 블록 내에 존재하게 된다.

   2] const

     0} 들어가기에 앞서...

       1) 사용 목적

         1| 상수(변하지 않는 값)를 위해

         2| 반드시 상수만을 위해 사용하지는 않는다.

     1} 선언과 초기화

       1) let과 const
   
         1| let : 재할당이 자유롭다.

         2| const : 재할당이 금지된다.

       
       2) 주의 사항 : const는 반드시 선언과 동시에 할당이 이루어져야 한다.
       -> 그렇지 않으면 문법 에러(SyntaxError)가 발생한다.

       3) 스코프 : 블록 레벨 스코프를 갖는다.

     2} 상수

       1) 사용해야 하는 이유 : 가독성과 유지보수의 편의를 위해 적극적으로 사용해야 한다.

     3} const와 객체

       1) const 변수의 타입이 객체인 경우 : 객체에 대한 참조를 변경하지 못한다.
       => 객체의 프로퍼티는 보호되지 않는다.
       -> 재할당은 불가능하지만 할당된 객체의 내용(프로퍼티의 추가, 삭제, 프로퍼티 값의 변경)은 변경할 수 있다.

       2) let과 const

         1| 객체 타입 변수 선언 : const를 사용하는 것이 좋다.

         2| 재할당(객체 타입 변수의 주소값을 변경) : let을 사용하는 것이 좋다.

   3] var vs. let vs. const

     1} ES6를 사용한다며 var 키워드는 사용하지 않는다.

     2} 재할당이 필요한 경우에 한정해 let 키워드를 사용한다.
     
     -> 변수의 스코프는 최대한 좁게 만든다.

     3} 변경이 발생하지 않는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다.

     -> const 키워드는 재할당을 금지하므로 var, let보다 안전하다.