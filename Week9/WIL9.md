기초 웹 스터디 9주차 - 2023년 5월 23일 화요일

이번 주 WIL인 WIL9에 담을 내용은 잘 정리되어 있는 래퍼런스 사이트에서 정해준 내용을 공부한 후 내가 새로 알게 된 내용 및 기억하고 싶은 내용을 정리한 것이다. 

## JavaScript

4,10,12,27,30,32.3,32.4

1. 브라우저 동작 원리
   
   1> 범용 개발 언어

     1} 자바스크립트는 Node.js의 등장으로 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 개발 언어가 되었다.

   2> 실행

     1} 대부분의 프로그래밍 언어 : 운영체제(Operating System, OS) 위에서 실행된다.

     2} 자바스크립트 : 브라우저에서 HTML, CSS와 함께 실행된다.

   3> 브라우저의 핵심 기능 : 사용자가 참조하고자 하는 웹페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것

     1} 브라우저 : 서버로부터 HTML, CSS, JavaScript, 이미지 파일 등을 응답받는다.

     2} HTML, CSS 파일 : 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.

     3} 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 표시한다.

   4> 엔진 처리

     1} 자바스크립트 : 자바스크립트 엔진이 처리한다.

     2} HTML 파서 : script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.

     3} 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다.

     4} 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.

   5> 동기(Synchronous)

     1} 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript을 처리한다.

     2} 의미 : script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다.

     => script 태그의 위치 : 중요한 의미를 갖는다.

     3} 자바스크립트 위치
     
       (1) 위치 : body 요소의 가장 아래

       (2) 이유

         1| HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.

         2| DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다.

2. 객체

  1] 객체(Object)란?

    0} 들어가기에 앞서...

     (1) 자바스크립트의 객체
       
       1| 정의 : 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합

       2| 객체지향의 상속을 구현하기 위해 "프로토타입(prototype)"이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다.

     (2) 프로퍼티의 값 : 자바스크립트에서 사용할 수 있는 모든 값
     => 함수도 사용할 수 있다.
     -> 일반 함수와 구분하기 위해 메소드라 부른다.

     (3) 객체
       
       1| 정의 : 데이터를 의미하는 프로퍼티(property)와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합

       2| 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다.
       => 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문이다.

    1} 프로퍼티

     (1) 구성
        
       1| 프로퍼티 키(이름) : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값
         
       2| 프로퍼티 값 : 모든 값

     (2) 식별

       1| 프로퍼티 키로 유일하게 식별할 수 있다.

       2| 식별자(identifier) : 프로퍼티 키

     (3) 프로퍼티 키

       1| symbol 값 이외의 값을 지정 : 암묵적으로 타입이 변환되어 문자열이 된다.

       2| 중복 선언 : 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.

     (4) 순서 : 객체는 프로퍼티를 열거할 때 순서를 보장하지 않는다.

    2} 메소드

     (1) 프로퍼티 값이 함수일 경우 : 일반 함수와 구분하기 위해 메소드라 부른다.

     (2) 의미 : 객체에 제한되어 있는 함수

  2] 객체 생성 방법

    0} 들어가기에 앞서...

     (1) 객체 생성 방법

       1| 클래스 기반 객체 지향 언어 : 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴슬르 생성하는 방식
       -> 클래스 기반 객체 지향 언어의 예시 : 자바

       2| 자바스크립트(프로토타입 기반 객체 지향 언어) : 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다.

       3| 문법적 설탕(Syntactic sugar) : ES6의 클래스가 새로운 객체지향 모델을 제공하는 것이 아니며 클래스도 사실 함수이고 기존 프로토타입 기반 패턴의 문법적 설탕(Syntactic sugar)이다.

    1} 객체 리터럴

     (1) 가장 일반적인 자바스크립트의 객체 생성 방식

     (2) 클래스 기반 객체 지향 언어와 비교할 때 매우 간편하게 객체를 생성할 수 있다.

     (3) 중괄호({})를 사용하여 객체 생성

       1| {} 내에 1개 이상의 프로퍼티를 기술한 경우 : 해당 프로퍼티가 추가된 객체를 생성할 수 있다.

       2| {} 내에 아무것도 기술하지 않은 경우 : 빈 객체가 생성된다.

    2} Object 생성자 함수

     (1) 객체 생성 방법

       1| new 연산자와 Object 생성자 함수를 호출하여 빈 객체를 생성할 수 있다.

       2| 프로퍼티 또는 메소드를 추가하여 객체를 완성한다.

     (2) 생성자(constructor) 함수

       1| 정의 : new 키워드와 함께 객체를 생성하고 초기화하는 함수

       2| 인스턴스(instance) : 생성자 함수를 통해 생성된 객체

       3| 빌트인 생성자 함수

         1/ 자바스크립트 : Object, String, Number, Boolean, Array, Date, RegExp 등

       4| 일반 함수와 생성자 함수의 구분 : 생성자 함수의 이름은 파스칼 케이스(PascalCase)를 사용한다.

       5| 할당

         1/ 객체가 소유하고 있지 않은 프로퍼티 키 : 해당 객체에 프로퍼티를 추가하고 값을 할당한다.

         2/ 이미 존재하는 프로퍼티 키 : 프로퍼티 값이 할당한 값으로 변경된다.

     (3) 객체 리터럴과 Object 생성자 함수

       1| 빈 객체 생성 : 객체 리터럴을 사용하는 것이 더 간편하다.

       2| 객체 리터럴 방식으로 생성된 객체 : 빌트인(Built-in) 함수인 Object 생성자 함수로 객체를 생성하는 것을 단순화시킨 축약 표현(short-hand)

    3} 생성자 함수

     (1) 객체 리터럴 방식과 Object 생성자 함수 방식의 불편한 점

       1| 객체 생성 : 프로퍼티 값만 다른 여러 개의 객체를 생성할 때 불편하다.

       2| 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야 한다.

     (2) 객체 생성
        
       1| 마치 객체를 생성하기 위한 템플릿(클래스)처럼 사용하여 프로퍼티가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

       2| 생성자 함수 이름 : 일반적으로 대문자로 시작한다.
       => 생성자 함수임을 인식하도록 도움을 준다.

       3| this : 생성자 함수가 생성할 인스턴스(instance)를 가리킨다.

       4| 프로퍼티와 메소드 : public(외부에서 참조 가능)하다.
       -> 프로퍼티와 메소드는 this에 연결(바인딩)되어 있다.

       5| 일반 변수 : private(외부에서 참조 불가능)하다.
       -> 일반 변수는 생성자 함수 내에서 선언된다.
         
       6| 접근 가능성
         
         1/ 생성자 함수 내부 : 자유롭게 접근이 가능하다.

         2/ 생성자 함수 외부 : 접근할 수 없다.

     (3) 자바스크립트의 생성자 함수

       1| 정의 : 객체를 생성하는 함수

       2| 방법
         
         1/ 그 형식이 정해져 있는 것이 아니라 기존 함수와 동일한 방법으로 생성자 함수를 선언한다.

         2/ new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.
         => 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것을 의미

  3] 객체 프로퍼티 접근

    1} 프로퍼티 키

     (1) 지정

       1| 문자열이나 symbol 값 : 문자열 지정 (빈 문자열 포함) 

       2| 이외의 값 : 암묵적으로 타입이 변환되어 문자열이 된다.

     (2) 따옴표('' 또는 "")

       1| 프로퍼티 키는 문자열이므로 따옴표('' 또는 "")를 사용한다.

       2| 따옴표 생략 : 자바스크립트에서 사용 가능한 유효한 이름은 경우

     (3) 사용

       1| 표현식 : 키로 사용할 표현식을 대괄호로 묶어야 한다.

       2| 예약어 : 에러가 발생하지는 않는다.
       => 하지만 예상치 못한 에러가 발생할 수 있으므로 예약어를 프로퍼티 키로 사용해선 안된다.

    2} 프로퍼티 값 읽기

     (1) 객체의 프로퍼티 값에 접근하는 방법

       1| 마침표(.) 표기법 : 프로퍼티 키가 유효한 자바스크립트 이름이고 예약어가 아닌 경우 사용

       2| 대괄호([]) 표기법

         1/ 프로퍼티 키가 유효한 자바스크립트 이름이고 예약어가 아닌 경우 사용

         2/ 프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우

         3/ 주의 사항 : 대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열이어야 한다.

     (2) 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다.

    3} 프로퍼티 값 갱신 : 객체가 소유하고 있는 프로퍼티에 새로운 값을 할당했을 때

    4} 프로퍼티 동적 생성
     
     (1) 객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 주어진 키와 값으로 프로퍼티를 생성한다.
      
     (2) 객체에 추가한다.

    5} 프로퍼티 삭제 : delete 연산자를 사용한다.
    => 피연산자 : 프로퍼티 키

    6} for-in 문

     (1) 정의 : 객체의 문자열 키(key)를 순회하기 위한 문법 

     (2) 사용 : 객체(배열 포함)에 포함된 모든 프로퍼티에 대해 수행할 수 있다.

     (3) 배열을 사용하지 않는 것이 좋다.

       1| 이유

         1/ 객체 : 프로퍼티의 순서가 보장되지 않는다.
         => 원래 객체의 프로퍼티에는 순서가 없기 때문이다.

         2/ 배열 : 프로퍼티의 순서가 보장되지 않는다.
         => 배열은 순서가 보장하는 데이터 구조이지만 윗 문장과 같이 실행된다.

         3/ 배열 요소들만을 순회하지 않는다.

     (4) 단점 극복 : for-of 문 추가(in ES6)

     (5) for-in 문과 for-of 문

       1| for-in 문 : 객체의 프로퍼티를 순회하기 위해 사용

       2| for-of 문 : 배열의 요소를 순회하기 위해 사용

  4] Pass-by-reference

    1} object type

     (1) 정의 : 객체 타입 또는 참조 타입

       1| object type : 객체 타입 또는 참조 타입

       2| 참조 타입 : 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.

     (2) 타입

       1| 참조 타입

         1/ 의미 : 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.

       2| 원시 타입

         1/ 값이 한 번 정해지면 변경할 수 없다.(immutable)
         => 객체 : 변경 가능(mutable)한 값
         -> 프로퍼티를 변경, 추가, 삭제가 가능하다.

         2/ pass-by-value : 값(value)으로 전달된다.
         => 복사되어 전달된다.

       3| 객체 타입

         1/ 값이 한 번 정해지면 변경할 수 없다.(immutable)
         => 프로퍼티를 변경, 추가, 삭제가 가능하다.

         2/ 런타임에 메모리 공간을 확보하고 메모리의 힙 영역(Heap Segment)에 저장된다.
         => 객체 타입 : 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기 때문에

  5] Pass-by-value

    1} 원시 타입

     (1) 값 : 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다.

  6] 객체의 분류

    1} Built-in Object(내장 객체)

     (1) 웹페이지 등을 표현하기 위한 공통의 기능을 제공한다.

     (2) 웹페이지가 브라우저에 의해 로드되자마자 별다른 행위 없이 바로 사용이 가능하다.

     (3) 구분

       1| Standard Built-in Objects (or Global Objects)

       2| Native Object

         1/ BOM (Browser Object Model)

         2/ DOM (Document Object Model)

     (4) Host Object(사용자 정의 객체)

       1| 정의 : 사용자가 생성한 객체

       2| Built-in Object와 Native Object가 구성된 이후에 구성된다.
       => constructor 혹은 객체 리터럴을 통해 사용자가 객체를 정의하고 확장시킨 것들이기 때문이다.

3. 함수

  0] 들어가기에 앞서...

    1} 함수

     (1) 정의 : 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록

     => 이름과 매개변수를 갖는다.

     (2) 호출

       1| 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 

       2| 여러 번 호출할 수 있다.

     (3) 코드의 재사용이 가능하다.
      
     => 매우 유용한 특성이다.

     (4) 기능

       1| 일반적 기능의 목적 : 어떤 작업을 수행하는 문(sttement)들의 집합을 정의하여 코드의 재사용에 목적이 있다.

       2| 또 다른 기능 : 객체 생성, 객체의 행위 정의(메소드), 정보 은닉, 클로저, 모듈화 등

     (5) 자바스크립트

       1| 함수 : 객체(일급 객체, First-class object)
       => 다른 값들처럼 사용할 수 있다.

       2| 다른 객체와 구분될 수 있는 특징 : 호출할 수 있다는 것

  1] 함수 정의

    0} 들어가기에 앞서...
     
     (1) 함수를 정의하는 방식

       1| 함수 선언문

       2| 함수 표현식

       3| Function 생성자 함수

    1} 함수 선언문

     (1) 함수 선언(Function declaration)방식으로 정의한 함수

       1| function 키워드

       2| 함수명 : 함수 몸체에서 자신을 재귀적(recursive) 호출하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자
       => 생략할 수 없다.

       3| 매개변수 목록

         1/ 0개 이상의 목록으로 괄호로 감싸고 콤마로 분리한다.

         2/ 다른 언어와의 차이점 : 매개변수의 타입을 기술하지 않는 것
         => 함수 몸체 내에서 매개변수의 타입 체크가 필요할 수 있다.

       4| 함수 몸체

         1/ 정의 : 함수가 호출되었을 때 실행되는 문들의 집합

         2/ 반환값(return value) : 중괄호({})로 문들을 감싸고 return문으로 반환한 결과값

    2} 함수 표현식

     (1) 자바스크립트의 함수의 특징

       1| 무명의 리터럴로 표현이 가능하다.

       2| 변수나 자료 구조(객체, 배열...)에 저장할 수 있다.

       3| 함수의 파라미터로 전달할 수 있다.

       4| 반환값(return value)으로 사용할 수 있다.

     (2) 정의 : 함수 리터럴 방식으로 함수를 정의하고 변수에 할당하는 방식

     (3) 익명 함수(anonymous function) : 함수명이 생략된 함수
      
     => 함수 표현식 방식으로 정의한 함수는 함수명을 생략할 수 있다.
      
     -> 생략하는 것이 일반적이다.

     (4) 변수가 함수명이 아닌 할당된 함수를 가리키는 참조값을 저장하게 된다.

     (5) 호출
      
       1| 함수 호출 시 함수를 가리키는 변수명을 사용하여야 한다.

       2| 함수가 할당된 변수를 사용해 함수를 호출하지 않고 기며 ㅇ함수의 함수명을 사용해 호출하게 되면 에러가 발생한다.
       => 함수 표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다.

       3| 함수명의 역할

         1/ 함수 몸체에서 자신을 재귀적 호출(Recursive function call)하는 식별자의 역할을 한다.

         2/ 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자의 역할을 한다.

    => 함수 선언문도 함수 표현식과 동일하게 함수 리터럴 방식으로 정의되는 것이다.

    3} Function 생성자 함수

     (1) 함수 선언문과 함수 표현식은 모두 함수 리터럴 방식으로 함수를 정의한다.

     => 내장 함수 Function 생성자 함수로 함수를 생성하는 것을 단순화시킨 short-hand(축약법)이다.

     (2) Function.prototype.constructor 프로퍼티로 접근할 수 있다.

     (3) Function 생성자 함수로 함수를 생성하는 방식은 일반적으로 사용하지 않는다.

  2] 함수 호이스팅

    1} 정의 : 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능하다.

    2} 자바스크립트 : ES6의 모든 선언을 호이스팅(Hoisting)한다.

    => 모든 선언 : var, let, const, function, function*, class

    3} 호이스팅의 정의 : 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성

    => 자바스크립트 : 모든 선언문이 선언되기 이전에 참조 가능하다.

    4} 함수 선언문으로 정의된 함수 : 함수 선언, 초기화, 할당이 한번에 이루어진다.

    => 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.

    -> 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당한다.

    5} 함수 표현식으로 정의된 함수 : 변수 호이스팅이 발생한다.

     (1) 변수 호이스팅

       1| 초기화 : 호이스팅된 변수는 undefined로 초기화 된다.

       2| 할당 : 실제값의 할당은 할문에서 이루어진다.

     -> 스크립트 로딩 시점에 runtime에 해석되고 실행된다.

  3] First-class object (일급 객체)

    1} 의미 : 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상

    2} 조건

     (1) 무명의 리터럴로 표현이 가능하다.

     (2) 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.

     (3) 함수의 매개변수에 전달할 수 있다.

     (4) 반환값으로 사용할 수 있다.

    => 자바스크립트의 함수 : 일급객체

  4] 매개변수(Parameter, 인자)

    0} 들어가기에 앞서...

     (1) 지정 : 함수의 작업 실행을 위해 추가적인 정보가 필요할 경우, 매개변수르 지정한다.

     (2) 함수 내에서 변수와 동일하게 동작한다.

    1} 매개변수(parameter, 인자) vs. 인수(argument)

     (1) 매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 함수에 전달한 인수는 매개변수에 할당된다.
     => 인수를 전달하지 않은 경우 : 매개변수는 undefined로 초기화된다.

    2} Call-by-value

     (1) 정의 : 함수 호출 시 원시 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식
     => 원시 타입 인수는 Call-by-value(값에 의한 호출)로 동작한다.
     -> 변경 O : 함수 내에서 매개변수를 통해 값이 변경된다.
     -> 변경 X : 전달이 완료된 원시 타입 값

    3} Call-by-reference

     (1) 정의 : 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 잔달되는 방식
     => 객체형(참조형) 인수는 Call-by-reference(참조에 의한 호출)로 동작한다. 

     (2) 함수 내에서 매개변수의 참조값이 이용하여 객체의 값을 변경했을 때 전달되어진 참조형의 인수값도 같이 변경된다.
     => 부수 효과(side-effect) 발생
     -> 부수 효과(side-effect) : 원본 객체가 변경되는 것

     (3) 순수 함수와 비순수 함수

       1| 순수 함수(Pure function) : 어떤 외부 상태도 변경하지 않는 함수

       2| 비순수 함수(Impure function) : 외부 상태도 변경시키는 부수 효과(side-effect)를 발생시키는 함수
       => 복잡성을 증가시킨다.
       => 비순수 함수를 최대한 줄이는 것 = 부수 효과를 최대한 억제하는 것

  5] 반환값

    1} return 키워드 : 함수를 호출한 코드(caller)에게 값을 반환할 때 사용한다.

    2} 함수

     (1) 배열 등을 이용하여 한 번에 여러 개의 값을 리턴할 수 있다.

     (2) 반환을 생략할 수 있다.
     => 함수는 암묵적으로 undefined를 반환한다.

     (3) 자바스크립트 해석기 : return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다.
     => 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다.

  6] 함수 객체의 프로퍼티

    1} arguments 프로퍼티

     (1) arguments 객체
     
       1| 정의 : 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)

       2| 사용 : 함수 내부에서 지역 변수처럼 사용된다.
       => 함수 외부에서는 사용 X 

       3| 자바스크립트 : 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다.

     (2) 매개변수(parameter)는 인수(argument)로 초기화된다.

       1| 매개변수의 개수보다 인수를 적게 전달한 경우(multiply(), multiply(1)) : 인수가 전달되지 않은 매개변수는 undefined으로 초기화된다.

       2| 매개변수의 개수보다 인수를 더 많이 전달한 경우 : 초과된 인수는 무시된다.

       3| 런타임 시에 호출된 함수의 인자 개수를 확인하고 이에 따라 동작을 달리 정의할 필요가 있을 수 있다.
       => 유용하게 사용되는 것 : arguments 객체
       -> arguments 객체 : 매개변수 개수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하게 사용된다.

     (3) 자바스크립트 : 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다.

     (4) 유사배열객체(arrary-like-object)
     
       1| 정의 : length 프로퍼티를 가진 객체

       2| 배열이 아니므로 배열 메소드를 사용하는 에러가 발생하게 된다.
       => 배열 메소드 사용 : Function.prototype.call, Function.prototype.apply를 사용하여야 한다.

    2} caller 프로퍼티

     (1) 의미 : 자신을 호출한 함수

    3} length 프로퍼티

     (1) 의미 : 함수 정의 시 작성된 매개변수 개수

     (2) arguments.length : 함수 호출 시 인자의 개수

     => 주의 사항 : length 프로퍼티와 arguments.length의 값은 다를 수 있다.

    4} name 프로퍼티 : 함수명

     (1) 기명함수의 경우 : 함수명을 값으로 갖는다.

     (2) 익명함수의 경우 : 빈문자열을 값으로 갖는다.

    5} __proto__ 접근자 프로퍼티

     (1) 모든 객체는 [[Prototype]]이라는 내부 슬롯이 있다.
     => [[Prototype]] 내부 슬롯은 프로토타입 객체를 가리킨다.

     (2) 프로토타입 객체

       1| 정의
       
         1/ 프로토타입 기반 객체 지향 프로그래밍의 근간을 이루는 객체

         2/ 다른 객체에 공유 프로퍼티를 제공하는 객체

       2| 사용 목적 : 객체 간의 상속(Inheritance)을 구현하기 위해

       3| __proto__ 프로퍼티와 프로토타입 객체 : __proto__ 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 모든 객체의 프로토타입 객체인 Object.prototype 객체의 프로퍼티이다.

     (3) 정의 : [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체 접근하기 위해 사용하는 접근자 프로퍼티

     (4) 접근

       1| 내부 슬롯 : 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.

       2| [[Prototype]] 내부 슬롯 : 직접 접근할 수 없으며 __proto__ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다.

     (5) 상속 : 모든 객체는 상속을 통해 __proto__접근자 프로퍼티를 사용할 수 있다.

     (6) 함수 : 함수도 객체이므로 __proto__ 접근자 프로퍼티를 통해 프로토타입 객체에 접근할 수 있다.

    6} prototype 프로퍼티

     (1) 함수 객체만이 소유하는 프로퍼티이다.

     => 일반 객체 : prototype 프로퍼티 X

     (2) 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체를 가리킨다.

  7] 함수의 다양한 형태

    1} 즉시 실행 함수(IIFE, Immediately Invoke Function Expression)

     (1) 정의 : 함수의 정의와 동시에 실행되는 함수

     (2) 특징 : 최초 한 번만 호출되며 다시 호출할 수는 없다.
     => 최초 한 번만 실행이 필요한 초기화 처리 등에 사용할 수 있다.

     (3) 자바스크립트의 문제점

       1| 파일이 분리되어 있다하여도 글로벌 스코프가 하나이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능하다는 것이다.
       => 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치 않는 결과를 가져올 수 있다.

       2| 즉시 실행 함수 사용 : 즉시 실행 함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 또는 함수의 충돌을 방지할 수 있다. 

    2} 내부 함수(Inner function)

     (1) 정의 : 함수 내부에 정의된 함수

     (2) 부모 함수와 자식 함수

       1| 부모 함수는 자식 함수(내부 함수)의 변수에 접근할 수 없다.

       2| 내부 함수는 부모 함수의 외부에서 접근할 수 없다.

    3} 재귀 함수(Recursive function) 

     (1) 정의 : 자기 자신을 호출하는 함수

     (2) 탈출 조건

       1| 자신을 무한히 연쇄 호출하므로 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.

       2| 탈출 조건이 없는 경우 : 함수가 무한 호출되어 stackoverflow 에러가 발생한다.
       -> 주의해야 할 점이다.

     (3) 구현 : for나 while 문으로 구현이 가능하다.
     => 반복문보다 재귀 함수를 통해 보다 직관적으로 이해하기 쉬운 구현이 가능한 경우에만 한정적으로 적용하는 것이 바람직하다.

    4} 콜백 함수(Callback function)

     (1) 정의 : 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수

     (2) 예시 : 이벤트 핸들러 처리

     (3) 실행 : 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다.

     (4) 비동기식 처리 모델(Asynchronous processing model) : 처리가 종료하면 호출될 함수(콜백 함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백 함수를 호출하는 것이다.
     => 콜백 함수는 주로 비동기식 처리 모델에 사용된다.

     (5) 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다.
     => 콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백 함수를 전달받은 함수의 변수에 접근할 수 있다.

4. 배열
   
  0] 들어가기에 앞서...

    1} 배열(array)

     (1) 사용 : 1개의 변수에 여러 개의 값을 순차적으로 저장할 때

     (2) 자바스크립트 : 자바스크립트의 배열은 객체이며 유용한 내장 메소드를 포함하고 있다.

     (3) 객체

       1| 배열 : Array 생성자로 생성된 Array 타입의 객체

       2| 프로토타입 객체 : Array.prototype

  1] 배열의 생성

    1} 배열 리터럴

     (1) 표현 방식 : 0개 이상의 값을 쉼표로 구분하여 대괄호([])로 묶는다.

     (2) 첫 번째 값 : 인덱스 '0'으로 읽을 수 있다.

     (3) 존재하지 않는 요소에 접근하면 undefined를 반환한다.

     (4) 프로퍼티명이 없고 각 요소의 값만이 존재한다.

     (5) 요소에 접근하기 위해 대괄호 표기법만을 사용하며 대괄호 내에 접근하고자 하는 요소의 인덱스를 넣어준다.
     => 인덱슨느 0부터 시작한다.

     (6) 자바스크립트 배열 : 어떤 데이터 타입의 조합이라도 포함할 수 있다.

    2} Array() 생성자 함수

     (1) 배열의 생성 : (일반적으로) 배열 리터럴 방식으로 생성

     (2) 배열 리터럴 방식 : 내장 함수 Array() 생성자 함수로 배열을 생성하는 것을 단순화시킨 것

     (3) Array 생성자 함수
     
       1| Array.prototype.constructor 프로퍼티로 접근할 수 있다.

       2| 매개변수의 개수

         1/ 매개변수가 1개이고 숫자인 경우 : 매개변수로 전달된 숫자를 length 값으로 가지는 빈 배열을 생성한다.

         2/ 그 외의 경우 : 매개변수로 전달된 값들을 요소로 가지는 배열을 생성한다.

  2] 배열 요소의 추가와 삭제

    1} 배열 요소의 추가

     (1) 동적으로 요소를 추가하기

       1| 순서에 맞게 값을 할당할 필요는 없고 인덱스를 사용하여 필요한 위치에 값을 할당한다.

       2| 배열의 길이(length) : 마지막 인덱스를 기준으로 산정된다.

     (2) 존재하지 않는 요소 참조 : undefined 반환

     (3) 주의 사항 : 값이 할당되지 않은 인덱스 위치의 요소는 생성되지 않는다.

    2} 배열 요소의 삭제

     (1) 방법 : delete 연산자 사용 
     => 배열은 객체이기 때문이다.

     (2) length에는 변함이 없다.
     => length에도 반영되게 하는 방법 : Array.prototype.splice 메소드를 사용한다.

    3} 배열의 순회

     (1) for...in 문 사용 : 배열 요소뿐만 아니라 불필요한 프로퍼티까지 출력될 수 있고 요소들의 순서를 보자하지 않으므로 배열을 순회하는데 적합하지 않다.

     (2) 적합한 문들 : forEach 메소드, for 문, for...of 문

  4] Array Property

    1} Array.length

     (1) length 프로퍼티 : 요소의 개수(배열의 길이)를 나타낸다.

     (2) 배열 인덱스 : 32bit 양의 정수로 처리된다.
     => length 프로퍼티의 값 : 양의 정수
     -> 2^32 - 1(4,294,967,296 - 1) 미만이다.

     (3) 주의 사항 : 배열 요소의 개수와 length 프로퍼티의 값이 반드시 일치하지는 않는다.

     (4) 희소 배열(sparse array)
     
       1| 정의
       
         1/ 배열 요소의 개수와 length 프로퍼티의 값이 일치하지 않는 배열

         2/ 배열의 요소가 연속적이지 않은 배열

       2| (배열의 요소 개수) < (length 프로퍼티의 값)

       3| 희소 배열은 일반 배열보다 느리며 메모리를 낭비한다.

     (5) length 프로퍼티 값보다 더 큰 인덱스로 요소를 추가하는 경우 : 새로운 요소를 추가할 수 있도록 자동으로 length 프로퍼티의 값이 늘어난다.
     => length 프로퍼티의 값 = 가장 큰 인덱스에 1을 더한 것

     (6) length 프로퍼티의 값을 현재보다 작게 변경하면 변경된 length 프로퍼티의 값보다 크거나 같은 인덱스에 해당하는 요소는 모두 삭제된다.

  5] Array Method

    1} Array.isArray(arg: any): boolean

     (1) 정적 메소드이다.

     (2) 주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다.

    2} Array.from

     (1) ES6에서 새롭게 도입된 메소드이다.

     (2) 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable)를 변환하여 새로운 배열을 생성한다.

    3} Array.of

     (1) ES6에서 새롭게 도입된 메소드이다.

     (2) 전달된 인수를 요소로 갖는 배열을 생성한다.

     (3) Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.

    4} Array.prototype.indexOf(searchElement: T, fromIndex?: number): number

     (1) 반환 : 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.

      1| 중복되는 요소가 있는 경우 : 첫 번째 인덱스를 반환한다.

      2| 해당하는 요소가 없는 경우 : -1을 반환한다.

     (2) 배열에 요소가 존재하는지 여부를 확인할 때 유용하다.

     (3) Array.prototype.includes 메소드

      1| ES7에서 새롭게 도입된 메소드이다.

      2| 보다 가독성이 좋다.

    5} Array.prototype.concat(...items: Array<T[]|T>): T[]

     (1) 인수로 전달된 값들(배열 또는 값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다.

     (2) 인수로 전달한 값이 배열인 경우 : 배열을 해체하여 새로운 배열의 요소로 추가한다.
     => 원본 배열은 변경되지 않는다.

    6} Array.prototype.join(separator?: string): string

     (1) 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 값, 즉 구분자(separator)로 연결한 문자열을 반환한다.

     (2) 구분자(separator)

       1| 생략 가능하다.

       2| 기본 구분자 : ,

    7} Array.prototype.push(...items: T[]): number

     (1) 인수로 전달받은 모든 값을 원본 배열의 마지막에 요소로 추가하고 변경된 length 값을 반환한다.

     (2) push 메소드와 concat 메소드

       1| push 메소드
       
         1/ 원본 배열을 직접 변경한다.

         2/ 인수로 전달받은 값이 배열인 경우 : 배열을 그대로 원본 배열의 마지막 요소로 추가한다.

         3/ 배열의 마지막에 요소를 추가한다.
         => length 프로퍼티를 사용하여 직접 요소를 추가할 수도 있다.
         -> 이 방법이 push 메소드보다 빠르다.

         4/ 원본 배열을 직접 변경하는 부수 효과가 있다.

       2| concat 메소드

         1/ 원본 배열을 변경하지 않고 새로운 배열을 반환한다.

         2/ 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.

    8} Array.prototype.pop(): T | undefined

     (1) 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.
     => 원본 배열이 빈 배열인 경우 : undefined를 반환한다.

     (2) pop 메소드 : 원본 배열을 직접 변경한다.
     => pop 메소드와 push 메소드를 사용하면 스택을 쉽게 구현할 수 있다.

     (3) 스택(stack)
     
       1| 정의 : 데이터를 마지막에 밀어 넣고, 마지막에 멀어 넣은 데이터를 먼저 꺼내는 후입 선출(LIFO - Last In First Out) 방식의 자료 구조

       2| 언제나 가장 마지막에 밀어 넣은 최신 데이터를 취득한다.

       3| push(푸시) : 스택에 데이터를 밀어 넣는 것

       4| pop(팝) : 스택에서 데이터를 꺼내는 것

    9} Array/prototype.reverse(): this

     (1) 배열 요소의 순서를 반대로 변경한다.
     => 원본 배열이 변경된다.

     (2) 반환값 : 변경된 배열

    10} Array.prototype.shift(): T | undefined

     (1) 배열에서 첫 요소를 제거하고 제거한 요소를 반환한다.

     => 빈 배열일 경우 : undefined를 반환한다.

     (2) shift 메소드
     
       1| 대상 배열 자체를 변경한다.

       2| push와 함께 배열을 큐(FIFO: First In First Out)처럼 동작하게 한다.

    11} Array.prototype.slice(start=0, end=this.length): T[]

     (1) 인자로 지정된 배열된 부분을 복사하여 반환한다.
     => 원본 배열은 변경 X

     (2) 첫 번째 매개변수 start에 해당하는 인덱스를 갖는 요소부터 매개변수 end에 해당하는 인덱스를 가진 요소 전까지 복사된다.

     (3) 매개변수

       1| start
       
         1/ 정의 : 복사를 시작할 인덱스

         2/ 음수인 경우 : 배열의 끝에서의 인덱스를 나타낸다.

         3/ 예시 - slice(-2) : 배열의 마지막 2개의 요소를 반환한다.

       2| end : 옵션이며 기본값은 length 값이다.

     (4) slice 메소드

       1| 인자를 전달하지 않은 경우 : 원본 배열의 복사본을 생성하여 반환한다.
       => 원본 배열의 각 요소를 얕은 복사(shallow copy)하여 새로운 복사본을 생성한다.
       -> 이를 이용하여 arguments, HTMLCollection, NodeList와 같은 유사 배열 객체(Array-like Object)를 배열로 변환할 수 있다.

       2| shallow copy : Spread 문법과 Object.assign는 원본을 shallow copy한다.

       3| Deep copy : loadash의 deepClone을 사용하는 것을 추천한다.

    12} Array.prototype.splice(start: number, deleteCount=this.length-start, ...itmes: T[]): T[]

     (1) 기존의 배열의 요소를 제거하고 그 위치에 새로운 요소를 추가한다.

     (2) 배열 중간에 새로운 요소를 추가할 때도 사용된다.

     (3) 매개변수

       1| start

         1/ 정의 : 배열에서의 시작 위치

         2/ start만을 지정하면 배열의 start부터 모든 요소를 제거한다.

       2| deleteCount

         1/ 정의 : 시작 위치(start)부터 제거할 요소의 수

         2/ deleteCount가 0인 경우 : 아무런 요소도 제거되지 않는다. (옵션)

       3| items

         1/ 정의 : 삭제한 위치에 추가될 요소의 수

         2/ 아무런 요소도 지정하지 않을 경우 : 삭제만 한다. (옵션)

     (4) 반환값 삭제한 요소들을 가진 배열

       1| 사용

         1/ 가장 일반적인 사용 : 배열에서 요소를 삭제할 때

         2/ 배열 중간에 새로운 요소를 추가할 때

         3/ 배열 중간에 배열의 요소들을 해체하여 추가할 때

       2| 배열에서 요소를 제거하고 제거한 위치에 다른 요소를 추가한다.

     (5) slice : 배열의 일부분을 복사하여 반환하며 원본을 훼손하지 않는다.

     (6) splice : 배열에서 요소를 제거하고 제거한 위치에 다른 요소를 추가하며 원본을 훼손한다.

5. 문서 객체 모델 DOM (Document Object Model)

  1] DOM (Document Object Model)

    1> 정의
    
     1| 브라우저의 렌더링 엔진이 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리를 적재하는 것

     2| 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체의 부자 관계를 표현할 수 있는 트리 구조로 구성한 것

     3| HTML, ECMAScript에 정의한 표준이 아닌 별개의 W3C의 공식 표준이며 플랫폼/프로그래밍 언어 중립적이다.

    2> DOM : 자바스크립트를 통해 동적으로 변경할 수 있다.
    -> 변경된 DOM : 렌더링에 반영된다.

    3> DOM API(Application Programming Interface)

     1| 정의 : DOM에 접근하고 변경하는 프로퍼티와 메소드의 집합
     
     2| 프로그래밍 언어가 자신에 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 자바스크립트 객체로 제공된다.

     2| 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법 : 메모리 상에 존재하는 DOM을 변경하는 것
     -> 이때 필요한 것 : DOM API

    4> DOM의 기능

     1| HTML 문서에 대한 모델 구성

       1/ 브라우저 : HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다.

       2/ DOM tree : 모델은 객체의 트리로 구성된다.

     2| HTML 문서 내의 각 요소에 접근/수정

       1/ DOM : 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다.

       2/ DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용도 변경된다.

  2] DOM tree

    1} 의미 : 브라우저가 HTML 문서를 로드한 후 피싱하여 생성하는 모델

    2} 명칭 이유 : 객체의 트리로 구조화되어 있기 때문이다.

    3} 객체

     (1) 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다.

     (2) DOM tree의 진입점(Entry point) : document 객체

     (3) DOM tree의 최종점 : 요소의 텍스트를 나타내는 객체

     (4) Node

       1| 문서 노드(Document Node)
       
         1/ 트리의 최상위에 존재하며 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다.
       
         2/ DOM tree에 접근하기 위한 시작점(entry point)

       2| 요소 노드(Element Node)
       
         1/ HTML 요소를 표현한다.
       
         2/ HTML 요소 : 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화한다.
       
         3/ 요소 노드 : 문서의 구조를 서술
       
         4/ 모든 요소 노드 : 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다.

       3| 어트리뷰트 노드(Attribute Node)
       
         1/ HTML 요소의 어트리뷰트를 표현한다.
       
         2/ 어트리뷰트 노드 : 해당 어트뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현된다.
       
         3/ 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있다.

       4| 텍스트 노드(Text Node)
       
         1/ HTML 요소의 텍스트를 표현한다.
       
         2/ 텍스트 노드 : 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다.
       -> 텍스트 노드 : DOM tree의 최종단이다.

     5| DOM tree를 크롬 브라우저를 확인하기
     
       1/ 개발자도구(Developer Tools)의 Elements를 선택한다.
       
       2/ 오른쪽의 properties을 선택한다.

     6| DOM을 통해 웹페이지를 조작(manipulate)하기

       1/ 조작하고자 하는 요소를 선택 또는 탐색한다.

       2/ 선택된 요소의 콘텐츠 또는 어트리뷰트를 조작한다.

     7| 자바스크립트 : 이것에 필요한 수단(API)을 제공한다.

  3] DOM Query / Traversing (요소에서의 접근)

    1} 하나의 요소 노드 선택(DOM Query)

      (1) document.getElementByld(id)

       1| id 어트리뷰트 값으로 요소 노드를 한 개 선택한다.
       => 북수 개가 선택된 경우 : 첫 번째 요소만 반환한다.

       2| Return : HTMLElement를 상속받는 객체

       3| 모든 브라우저에세 동작한다.

      (2) document.querySelector(cssSelector)

       1| CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다.
       => 복수 개가 선택된 경우 : 첫 번째 요소만 반환한다.

       2| Return : HTMLElement를 상속받은 객체

       3| IE8 이상의 브라우저에서 동작한다.

    2} 여러 개의 요소 노드 선택(DOM Query)

    (1) document.getElementsByClassName(class)

     1| class 어트리뷰트 값으로 요소 노드를 모두 선택한다.
     => 공백으로 구분하여 여러 개의 class를 지정할 수 있다.

     2| Return : HTMLCollection (live : 실시간으로 Node의 상태 변경을 반영한다.)
     => 반환값이 복수인 경우 : HTMLElement의 리스트를 담아 반환하기 위한 객체로 배열과 비슷한 사용법을 배열은 아닌 유사배열(array-like object)

     3| IE9 이상의 브라우저에서 동작한다.

     4| 주의 사항 : HTMLCollection은 실시간으로 Node의 상태를 변경하기 때문에 loop가 필요한 경우 주의가 필요하다.
     => 회피하는 방법 (아랫줄부터 적혀 있다.)

       1/ 반복문을 역방향으로 돌린다.

       2/ while 반복문을 사용한다.
       => elems에 요소가 남아 있지 않을 때까지 무한반복을 위해 index는 0으로 고정시킨다.

       3/ HTMLCollection을 배열로 변경한다.
       (=> 이 방법을 권장한다고 하셨다.)

       4/ querySelectorAll 메소드를 사용하여 HTMLCollection이 아닌 NodeList(non-live)를 반환하게 한다.

     (2) document.getElementsByTagName(tagName)

       1| 태그명으로 요소 노드를 모두 선택한다.

       2| Return: HTMLCollection (live)

       3| 모든 브라우저에서 동작한다.

     (3) document.querySelectorAll(selector)

       1| 지정된 CSS 선택자를 사용하여 요소 노드를 모두 선택한다.

       2| Return: NodeList (non-live)

       3| IE8 이상의 브라우저에서 동작한다.

  3] DOM Traversing (탐색)

    1} parentNode

     (1) 부모 노드를 탐색한다.

     (2) Return: HTMLElement를 상속받은 객체

     (3) 모든 브라우저에서 동작한다.

    2} firstChild, lastChild

     (1) 자식 노드를 탐색한다.

     (2) Return: HTMLElement를 상솏받은 객체

     (3) IE9 이상의 브라우저에서 동작

    => 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급한다.
    -> 회피 방법 : HITML의 공백을 제거하거나 jQuery: .prev()와 jQuery: .next()를 사용하거나 firstElementChild, lastElementChild를 사용한다.

    3} hasChildNodes()

     (1) 자식이 노드가 있는지 확인하고 Boolean 값을 반환한다.

     (2) Return: Boolean 값

     (3) 모든 브라우저에서 동작한다.

    4} childNodes

     (1) 자식 노드의 컬렉션을 반환한다.
     => 텍스트 요소를 포함한 모든 자식 요소를 반환한다.

     (2) Return : NodeList (non-live)

     (3) 모든 브라우저에서 동작한다.

    5} children

     (1) 자식 노드의 컬렉션을 반환한다.
     => 자식 요소 중에서 Element type 요소만을 반환한다.

     (2) Return : HTMLCollection (live)

     (3) IE9 이상의 브라우저에서 동작한다.

    6} previousSibling, nextSibling

     (1) 형제 노드를 탐색한다.
     => text node를 포함한 모든 형제 노드를 탐색한다.

     (2) Return : HTMLElement를 상속받은 객체

     (3) 모든 브라우저에서 동작한다.

    7} previousElementSibling, nextElementSibling

     (1) 형제 노드를 탐색한다.
     => 형제 노드 중에서 Element type 요소만을 탐색한다.

     (2) Return : HTMLElement를 상속받은 객체

     (3) IE9 이상의 브라우저에서 동작한다.

  4] DOM Manipulation (조작)

    1} 텍스트 노드에의 접근/수정

     (1) 요소의 텍스트 : 텍스트 노드에 저장되어 있다.

     (2) 텍스트 노드에 접근하기

       1| 해당 텍스트 노드의 부모 노드를 선택한다.
       => 텍스트 노드 : 요소 노드의 자식

       2| firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.

       3| 텍스트 노드의 유일한 프로퍼티(nodeValue)를 이용하여 텍스트를 취득한다.

       4| nodeValue를 이용하여 텍스트를 수정한다.

     (3) nodeValue

       1| 노드의 값을 반환한다.

       2| Return : 텍스트 노드의 경우는 문자열
       => 요소 노드의 경우 : null 반환

       3| IE6 이상의 브라우저에서 동작한다.

     (4) nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.

    2} 어트리뷰트 노드에의 접근/수정

     (1) className

       1| class 어트리뷰트의 값을 취득 또는 변경한다.

       2| className 프로퍼티에 값을 할당하는 경우 : class 어트리뷰트가 존재하지 않으면 class 어트리뷰트를 생성하고 지정된 값을 설정한다.

       3| class 어트리뷰트의 값이 여러 개일 경우 : 공백으로 구분된 문자열이 반환되므로 String 메소드(split(' '))를 사용하여 배열로 변경하여 사용한다.

       4| 모든 브라우저에서 동작한다.

     (2) classList

       1| add, remove, item, toggle, contains, replace 메소드를 제공한다.

       2| IE10 이상의 브라우저에서 동작한다.

     (3) id

       1| id 어트리부트의 값을 취득 또는 변경한다.

       2| id 프로퍼티에 값을 할당하는 경우 : id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정한다.

       3| 모든 브라우저에서 동작한다.

     (4) hasAttribute(attribute)

       1| 지정한 어트리뷰트를 가지고 있는지 검사한다.

       2| Return : boolean

       3| IE8 이상의 브라우저를 동작한다.

      (5) getAttribute(attribute) 

       1| 어트리뷰트의 값을 취득한다.

       2| Return : 문자열

       3| 모든 브라우저에서 동작한다.

      (6) setAttribute(atrribute, value)

       1| 어트리뷰트와 어트리뷰트 값을 설정한다.

       2| Return : undefined

       3| 모든 브라우저에서 동작한다.

      (7) removeAttribute(attribute)

       1| 지정한 어트리뷰트를 제거한다.

       2| Return : undefined

       3| 모든 브라우저에서 동작한다.

    3} HTML 콘텐츠 조작(Manipulation)

     (1) 주의 사항 : 마크업이 포함된 콘텐츠를 추가하는 행위는 크로스 스크립팅 공격(XSS: Cross-Site Scriptiong Attacks)에 취약하므로 주의가 필요하다.

     (2) textContent

       1| 요소의 텍스트 콘텐츠를 취득 또는 변경한다.
       => 마크업은 무시된다.

       2| textContent를 통해 요소에 새로운 텍스트를 할당하면 텍스트를 변경할 수 있다.
       => 순수한 텍스트만 지정해야 하며 마크업을 포함시키면 문자열로 인식되어 그대로 출력된다. 

       3| IE9 이상의 브라우저에서 동작한다.

     (3) innerText

       1| innerText 프로퍼티를 사용하여도 요소의 텍스트 콘텐츠에만 접근할 수 있다.
       => 사용하지 않는 것이 좋은 이유(아랫줄부터 적혀 있다.)

         1/ 비표준이다.

         2/ CSS에 순종적이다.
         => 예 : CSS에 의해 비표시(visibility: hidden;)로 지정되어 있다면 텍스트가 반환되지 않는다.

         3/ CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다.

     (4) innerHTML

       1| 해당 요소의 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다.
       => 문자열 : 마크업을 포함한다.

       2| 마크업이 포함된 새로운 콘텐츠를 지정할 때 : 새로운 요소를 DOM에 추가할 수 있다.
       => 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다.

    4} DOM 조작 방식

     (1) innerHTML 프로퍼티를 사용하지 않고 새로운 콘텐츠를 추가할 수 있는 방법 : DOM을 직접 조작하는 것

     (2) 한 개의 요소를 추가하는 경우

       1| 요소 노드 생성 createElement() 메소드를 사용하여 새로운 요소 노드를 생성한다.
       => createElement() 메소드의 인자로 태그 이름을 전달한다.

       2| 텍스트 노드 생성 createTextNode() 메소드를 사용하여 새로운 노드를 생성한다.
       => 생략하는 경우 : 콘텐츠가 비어 있는 요소가 된다.

       3| 생성된 요소를 DOM에 추가 appendChild() 메소드를 사용하여 생성된 노드를 DOM tree에 추가한다.

       4| 또는 removeChild() 메소드를 사용하여 DOM tree에서 노드를 삭제할 수도 있다.

     (3) createElement(tagName)

       1| 태그 이름을 인자로 전달하여 요소를 생성한다.

       2| Return : HTMLElement를 상속받은 객체

       3| 모든 브라우저에서 동작한다.

     (4) createTextNode(text)

       1| 텍스트를 인자로 전달하여 텍스트 노드를 생성한다.

       2| Return : Text 객체

       3| 모든 브라우저에서 동작한다.

     (5) appendChild(Node)

       1| 인자로 전달한 노드를 마지막 자식 요소로 DOM 트리에 추가한다.

       2| Return : 추가한 노드

       3| 모든 브라우저에서 동작한다.

     (6) removeChild(Node)

       1| 인자로 전달한 노드를 DOM 트리에 제거한다.

       2| Return : 추가한 노드

       3| 모든 브라우저에서 동작한다.

    5} insertAdjacentHTML()

     (1) insertAdjacentHTML(position, string)

       1| 인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다.
       => 첫번째 인자 : 삽입 위치를 표현한 문자열
       => 두번째 인자 : 삽입할 요소를 표현한 문자열
       => 첫번째 인자로 올 수 있는 값(아랫줄부터 작성함.)

         1/ 'beforebegin'

         2/ 'afterbegin'

         3/ 'beforeend'

         4/ 'afterend'

       2| 모든 브라우저에서 동작한다.

    6} innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML()

     (1) innerHTML

       1| 장점

         1/ DOM 조작 방식에 비해 빠르고 간편하다.

         2/ 간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다.

         3/ 콘텐츠를 취득할 수 있다.

       2| 단점

         1/ XSS 공격에 취약점이 있기 때문에 사용자로부터 입력받은 콘텐츠(untrusted data : 댓글, 사용자 이름 등)를 추가할 때 주의하여야 한다.

         2/ 해당 요소의 내용을 덮어 쓴다.
         => HTML을 다시 파싱한다.
         -> 비효율적이다.

     (2) DOM 조작 방식

       1| 장점

         1/ 특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합하다.

       2| 단점

         1/ innerHTML보다 느리고 더 많은 코드가 필요하다.

     (3) insertAdjacentHTML()

       1| 장점

         1/ 간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다.

         2/ 삽입되는 위치를 선정할 수 있다.

       2| 단점

         1/ XSS 공격에 취약점이 있기 때문에 사용자로부터 입력 받은 콘텐츠(untrusted data : 댓글, 사용자 이름 등)를 추가할 때 주의하여야 한다.

     (4) 결론

       1| innerHTML과 insertAdjacentHTML()은 크로스 스크립팅 공격(XSS : Cross-Site Scripting Attacks)에 취약하다.

       2| untrusted data
       
         1/ 텍스트를 추가 또는 변경 시 :  textContent을 사용하도록 한다.
         
         2/ 새로운 요소의 추가 또는 삭제 시 : DOM 조작 방식을 사용하도록 한다.

  5] style

    1} style 프로퍼티 사용

     (1) inline 스타일 선언을 생성한다.

     (2) 특정 요소에 inline 스타일을 지정하는 경우

    2} style 프로퍼티의 값을 취득하려면 window.getComputedStyle을 사용한다.

    3} window.getComputedStyle 메소드 : 인자로 주어진 요소의 모든 CSS 프로퍼티 값을 반환한다.

6. 이벤트

  1] 이벤트의 종류

    1} UI Event

     (1) load : 웹페이지의 로드가 완료되었을 때

     (2) unload : 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우)

     (3) error : 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우

     (4) resize : 브라우저 창의 크기를 조절했을 때

     (5) scroll : 사용자가 페이지를 위아래로 스크롤할 때

     (6) select : 텍스트를 선택했을 때

    2} Keyboard Event

     (1) keydown : 키를 누르고 있을 때

     (2) keyup : 누르고 있는 키를 뗄 때

     (3) keypress : 키를 누르고 뗐을 때

    3} Mouse Event

     (1) click : 마우스 버튼을 클릭했을 때

     (2) dbclick : 마우스 버튼을 더블 클릭했을 때

     (3) nousedown : 마우스 버튼을 누르고 있을 때

     (4) mouseup : 누르고 있던 마우스 버튼을 뗄 때

     (5) mousemove : 마우스를 움직일 때 (터치스크린에서 동작하지 않는다.)

     (6) mouseover : 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다.)

     (7) mouseout : 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다.)

    4} Focus Event

     (1) focus/focusin : 요소가 포커스를 얻었을 때

     (2) blur/foucusout : 요소가 포커스를 잃었을 때

    5} Form Event

     (1) input
     
       1| input 또는 textarea 요소의 값이 변경되었을 때

       2| contenteditable 어트리뷰트를 가진 요소의 값이 변경되었을 때

     (2) change : select box, checkbox, radio button의 상태가 변경되었을 때

     (3) submit : form을 submit할 때 (버튼 또는 키)

     (4) reset : reset 버튼을 클릭할 때 (최근에는 사용 안 함.)

    6} Clipboard Event

     (1) cut : 콘텐츠를 잘라내기할 때

     (2) copy : 콘텐츠를 복사할 때

     (3) paste : 콘텐츠를 붙여넣기할 때

  2] 이벤트 핸들러 등록

    1} 인라인 이벤트 핸들러 방식

     (1) 정의 : HTML 요소의 이벤트 핸들러 어트리뷰트에 이벤트 핸들러를 등록하는 방법

     (2) 호출

       1| on으로 시작하는 이벤트 어트리뷰트의 값으로 함수 호출을 전달한다는 것이다.

       2| DOM 요소의 이벤트 핸들러 프로퍼티에 함수 호출이 아닌 함수를 전달하는 경우

         1/ 이벤트 어트리뷰트 키를 이름으로 갖는 함수를 암묵적으로 정의하고 그 함수의 몸체에 이벤트 어트리뷰트의 값으로 전달한 함수 호출을 문으로 갖는다.
         => 이벤트 어트리뷰트의 값으로 전달한 함수 호출이 즉시 호출되는 것은 아니다.

       (3) 이벤트 어트리뷰트의 값 : 암묵적으로 정의되는 이벤트 핸들러의 문
       => 여러 개의 문 전달 가능

       (4) 이 방식은 더 이상 사용되지 않으며 사용해서도 안된다.
       => 오래된 코드에서 간혹 이 방식을 사용한 것이 있기 때문에 알아둘 필요는 있다.

    2} 이벤트 핸들러 프로퍼티 방식

     (1) HTML과 JavaScript가 뒤섞이는 문제를 해결할 수 있는 방식

     (2) 단점 : 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다.

    3} addEventListener 메소드 방식

     (1) addEventListener 메소드를 이용하여 대상 DOM 요소에 이벤트를 바인딩하고 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정한다.

     (2) 장점

       1| 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있다.

       2| 캡처링과 버블링을 지원한다.

       3| HTML 요소뿐만 아니라 모든 DOM 요소(HTML, XML, SVG)에 대해 동작한다.

       4| 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM을 생성한다.

     (3) 메소드

       1| addEventListener 메소드 : IE9 이상에서 동작한다.

       2| attachEvent 메소드 : IE8 이하에서 동작한다.

     (4) DOM 요소(target)를 지정하지 않으면 전역객체 즉 DOM 문서를 포함한 브라우저의 윈도우에서 발생하는 click 이벤트에 이벤트 핸들러를 바인딩한다.
     => 브라우저 윈도우 어디를 클릭하여도 이벤트 핸들러가 동작한다.